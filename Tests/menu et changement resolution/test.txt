/** * @file        sounds.c * @brief       Contient l'implÃ©mentation des fonctions en rapport avec la musique, la crÃ©ation des channels, le changement de volume etc * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/sounds.h"/** * \fn void creation_canaux_musique() * \brief Cette fonction alloue des canaux de musiques pour pouvoir mettre plusieurs sons en mÃªme temps comme les effets des joueurs ma Ã¹usique d'ambiance etc . . . */void creation_canaux_musique()
{
    if(Mix_AllocateChannels(7) == -1)quitter(SDL_MIXER);    /*Cannaux:     *0:Musique fond     *1:Effets joueur 1     *2:Effets Joueur 2     *3:Effets Joueur 3     *4:Effets Joueur 4     *5:Dialogues     *6:Buffer     */    jeu_parametres.musiques[MUSIQUE_INTRO]=Mix_LoadWAV(SRC_MUSIQUE_INTRO);
    jeu_parametres.musiques[MUSIQUE_ACCUEIL]=Mix_LoadWAV(SRC_MUSIQUE_ACCUEIL);
}/** * \fn void chargement_musique(int channel, int extra,int rep) * \brief Cette fonction permet de jouer une musique * \param channel Correspond au cannal de musique (0->6) * \param extra Indice dans le tableau jeu_parametres.musiques[] correspondant Ã  la musique voulu * \param rep Correspond au nombre de rÃ©pÃ©titions (-1 -> infini) */void chargement_musique(int channel, int extra,int rep)
{
    Mix_PlayChannel(channel, jeu_parametres.musiques[extra], rep);
}/** * \fn void changement_volumes_musiques() * \brief Cette fonction permet de changer les volumes des canaux de musiques */void changement_volumes_musiques()
{
    if(struct_jeu.focus_loose && !jeu_parametres.arriere_plan) //si on est sorti de l'ï¿½cran et que l'utilisateur a choisi de retirer le son    {        for(int i=0; i<7; i++)            if(Mix_Volume(i,0) == -1)quitter(SDL_MIXER);    }    else    {        if(Mix_Volume(0, jeu_parametres.musique/2) == -1)quitter(SDL_MIXER);        if(Mix_Volume(1, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(2, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(3, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(4, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(5, jeu_parametres.dialogues) == -1)quitter(SDL_MIXER);        if(Mix_Volume(6, jeu_parametres.musique/2) == -1)quitter(SDL_MIXER);    }}/** * \fn void detruire_musique(int extra) * \brief Cette fonction permet de libÃ©rer la musique stocker dans le tableau jeu_parametres.musiques[] */void detruire_musique(int extra){    Mix_FreeChunk(jeu_parametres.musiques[extra]);}/** * @file        main.c * @brief       Contient l'implÃ©mentation de la fonction int main() ainsi que tous les appels de librairies dynamiques pour sdl * @author      Meunier Rodrigue * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/struct.h"/** * \fn int main(int argc, char* argv[]) * \brief La fonction main ne sert qu'a appelÃ© la fonction accueil et dÃ©marage et surtout Ã  appeler les libraires dynamiques SDL * * \param argc Nombre d'arguments * \param argv Contient les arguments * \return 0 si aucune erreur */int main(int argc, char* argv[]){    /*      INITIALISATION DES LIBRAIRIES DYNAMQIUES        */    errno=0;    if(SDL_Init(SDL_INIT_EVERYTHING) !=0)quitter(SDL_BASE);    if( !(IMG_Init(IMG_INIT_PNG)) )quitter(SDL_IMAGE);    if(TTF_Init() != 0)quitter(SDL_TTF);    if(!Mix_Init(MIX_INIT_MP3))quitter(SDL_MIXER);    if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, MIX_DEFAULT_CHANNELS, 1024) == -1)quitter(SDL_MIXER); //Initialisation de l'API Mixer    /*------------------------------------------------------*/    initialisation_parametres();    //menu_parametre();    accueil();    //SDL_Delay(5000);    quitter(QUITTER);    return 0;}#include "include/actions.h"/** * \fn void pesanteur() * \brief Cette fonction applique de la gravité au joueur pour rendre le jeu plus réaliste * * */void pesanteur(){    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        if(!(struct_jeu.joueurs[i].positionY==RCT_Y_1 && struct_jeu.joueurs[i].positionX>=RCT_X_1 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_1 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_2 && struct_jeu.joueurs[i].positionX>=RCT_X_2 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_2 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_3 && struct_jeu.joueurs[i].positionX>=RCT_X_3 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_3 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_4 && struct_jeu.joueurs[i].positionX>=RCT_X_4 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_4 && struct_jeu.joueurs[i].etat!=JUMP))            struct_jeu.joueurs[i].positionY++;    }}/** * \fn void avancer() * \brief La fonction avancer permet de sois faire avancer sois faire reculer les joueurs si leur évent respectifs sont à 1 struct_jeu.tableau_event (cf struct.h) * */void avancer(){    for(int i=J1; i<J4; i++)    {        if(struct_jeu.tableau_event[i][0])        {            if(i%2)            {                struct_jeu.joueurs[i].direction=GAUCHE;                struct_jeu.joueurs[i].positionX-=2;            }            else            {                struct_jeu.joueurs[i].direction=DROITE;                struct_jeu.joueurs[i].positionX+=2;            }            struct_jeu.joueurs[i].etat=WALK;            struct_jeu.joueurs[i].modification=1;        }        if(struct_jeu.tableau_event[i][1])        {            if(i%2)            {                struct_jeu.joueurs[i].direction=DROITE;                struct_jeu.joueurs[i].positionX+=2;            }            else            {                struct_jeu.joueurs[i].direction=GAUCHE;                struct_jeu.joueurs[i].positionX-=2;            }            struct_jeu.joueurs[i].etat=WALK;            struct_jeu.joueurs[i].modification=1;        }    }}/** * \fn void sauter() * \brief Cette fonction permet de faire sauter le joueur * */void sauter(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][2])        {            struct_jeu.joueurs[i].positionY-=10;            struct_jeu.joueurs[i].etat=JUMP;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void attaquer() * \brief Cette fonction permet de faire attaquer le joueur et vérifie si un joueur est présent pour lui infliger des dégats * */void attaquer(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][3])        {            struct_jeu.joueurs[i].etat=ATTACK;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void coupspe() * \brief Coupspe est comme attaquer mais c'est l'attaque spécial, elle est plus forte * */void coupspe(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][4])        {            struct_jeu.joueurs[i].etat=ATTACK;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void repos() * \brief Les personnages étant animés, si un joueur est "immobile" le personnage passe en "idle" donc se met au repos, cette fonction permet de faire ce changement * */void repos(){    for(int i=J1; i<J4; i++)        if(!struct_jeu.joueurs[i].modification)            struct_jeu.joueurs[i].etat=IDLE;}/** * @file        draw.c * @brief       Contient toutes les fonctions en rapport avec l'affichage * @author      Meunier Rodrigue * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/draw.h"SDL_Color couleurBlanc  =   {255,255,255,255};SDL_Color couleurBleu   =   {0, 0, 255, 255};SDL_Color couleurOrange =   {255, 140, 40, 255};SDL_Color couleurVert   =   {0, 255, 0, 255};SDL_Color couleurJaune  =   {255, 255, 0, 255};SDL_Color couleurRose   =   {255, 110, 137, 255};SDL_Color couleurRouge  =   {255, 0, 0, 255};SDL_Color couleurNoir   =   {0, 0, 0, 255};const int tab_rapport_X_vies[4]= {RAPPORT_X_J1_VIE,RAPPORT_X_J2_VIE,RAPPORT_X_J3_VIE,RAPPORT_X_J4_VIE};/** * \fn void definir_resolutions() * \brief Cette fonction rempli le tableau de rÃ©solution*/void definir_resolutions(){    jeu_parametres.reso[0][0]=1280;    jeu_parametres.reso[1][0]=800;    jeu_parametres.reso[0][1]=1440;    jeu_parametres.reso[1][1]=900;    jeu_parametres.reso[0][2]=1680;    jeu_parametres.reso[1][2]=1050;    jeu_parametres.reso[0][3]=1920;    jeu_parametres.reso[1][3]=1080;    jeu_parametres.reso[0][4]=1920;    jeu_parametres.reso[1][4]=1200;    jeu_parametres.reso[0][5]=768;    jeu_parametres.reso[1][5]=1024;    jeu_parametres.reso[0][6]=1280;    jeu_parametres.reso[1][6]=1024;    jeu_parametres.reso[0][7]=320;    jeu_parametres.reso[1][7]=480;    jeu_parametres.reso[0][8]=1366;    jeu_parametres.reso[1][8]=768;}/** * \fn void chargerTextures() * \brief Cette fonction charge en mÃ©moire les textures globales comme celle de l'accueil ou encore celle des paramÃªtres*/void chargerTextures(){    // Crï¿½ation des textures pour les parametres    SDL_Surface *surf;    char *chaine=malloc(18*sizeof(char));    strcpy(chaine,SRC_IMG_PARA);    for(int i=0; i<9; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[13]++;// cette ligne permet d'incrï¿½menter le numï¿½ro de l'image '1'.png        jeu_parametres.tabMenu[i]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    jeu_parametres.page=0;    free(chaine);    // Crï¿½ation de la texture de l'accueil    surf=IMG_Load(SRC_IMG_ACCUEIL);    if(surf==NULL)quitter(SDL_IMAGE);    struct_jeu.texture_accueil=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);    if(struct_jeu.texture_accueil==NULL)quitter(SDL_BASE);    SDL_FreeSurface(surf);    //Crï¿½ation textures d'arriï¿½re plan jeu    chaine=malloc(26*sizeof(char));    strcpy(chaine,SRC_IMG_JEU);    for(int i=1; i<NB_IMG_FOND; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[21]++;// cette ligne permet d'incrï¿½menter le numï¿½ro de l'image '1'.png        struct_jeu.textures_fond_jeu[i-1]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    free(chaine);    //Crï¿½ation textures du plateau du jeu    chaine=malloc(29*sizeof(char));    strcpy(chaine,SRC_IMG_PLATEAU);    for(int i=1; i<NB_IMG_PLATEAU+1; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[24]++;// cette ligne permet d'incrï¿½menter le numï¿½ro de l'image '1'.png        struct_jeu.textures_plateau_jeu[i-1]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    free(chaine);    // Crï¿½ation de la texture du menu multijoueur    surf=IMG_Load(SRC_IMG_MULTI);    if(surf==NULL)quitter(SDL_IMAGE);    struct_jeu.texture_multijoueur=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);    if(struct_jeu.texture_multijoueur==NULL)quitter(SDL_BASE);    SDL_FreeSurface(surf);}/** * \fn void creation_textures_personnage() * \brief Cette fonction crÃ©er les textures en fonction du choix du joueur sur son personnage*/void creation_textures_personnage(){    SDL_Surface *surf=NULL;    char *chaine=NULL;    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        switch(struct_jeu.joueurs[i].type_personnage/10)        {        case 0:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_CHEVALIER));            strcpy(chaine,SRC_IMG_PERSONNAGE_CHEVALIER);            chaine[30]='0'+((struct_jeu.joueurs[i].type_personnage)%10);            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[32]='0'+y;                    chaine[34]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 1:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_ELFE));            strcpy(chaine,SRC_IMG_PERSONNAGE_ELFE);            chaine[25]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[27]='0'+y;                    chaine[29]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 2:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_FEE));            strcpy(chaine,SRC_IMG_PERSONNAGE_FEE);            chaine[24]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[26]='0'+y;                    chaine[28]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 3:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_WARRIOR));            strcpy(chaine,SRC_IMG_PERSONNAGE_WARRIOR);            chaine[28]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[30]='0'+y;                    chaine[32]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        }        free(chaine);    }    if(struct_jeu.nombre_joueurs)    {        if(struct_jeu.nombre_joueurs==2)        {            surf=IMG_Load(SRC_IMG_VIE2J);        }        else if(struct_jeu.nombre_joueurs==4)        {            surf=IMG_Load(SRC_IMG_VIE4J);        }        if(surf==NULL)quitter(SDL_IMAGE);        struct_jeu.vie_joueurs=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        if(struct_jeu.vie_joueurs==NULL)quitter(SDL_BASE);        SDL_FreeSurface(surf);    }}/** * \fn void destruction_textures_personnage() * \brief Comme nous pouvons pas nous pemettre de stocker des Go de texture il faut libÃ©rer les textures, cette fonction s'en charge*/void destruction_textures_personnage(){    for(int i=0; i<4; i++)        for(int j=0; j<6; j++)            for(int k=0; k<9; k++)                SDL_DestroyTexture(struct_jeu.textures_personnages_joueurs[i][j][k]);}/** * \fn void creation_fenetre() * \brief Cette fonction, appellÃ©e avant le chargement, crÃ©er la fenÃªtre qui accueillera les textures du jeu*/void creation_fenetre(){    SDL_Surface *icon=IMG_Load(SRC_IMG_ICON);    struct_jeu.fenetre_jeu=NULL;    struct_jeu.rendu_fenetre=NULL;    struct_jeu.fenetre_jeu=SDL_CreateWindow("Pepite De Fight",SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, jeu_parametres.reso[0][jeu_parametres.resolution], jeu_parametres.reso[1][jeu_parametres.resolution], 0);    struct_jeu.rendu_fenetre=SDL_CreateRenderer(struct_jeu.fenetre_jeu,-1,SDL_RENDERER_ACCELERATED);    if(struct_jeu.fenetre_jeu==NULL)quitter(SDL_BASE);    if(struct_jeu.rendu_fenetre==NULL)quitter(SDL_BASE);    SDL_SetWindowIcon(struct_jeu.fenetre_jeu,icon);    SDL_FreeSurface(icon);    SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_FULLSCREEN_DESKTOP);    SDL_GetWindowSize(struct_jeu.fenetre_jeu,&jeu_parametres.reso[0][9],&jeu_parametres.reso[1][9]);//rï¿½cupï¿½ration des dims max de la fenï¿½tre    SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_SHOWN);    struct_jeu.focus_loose=0;}/** * \fn int creation_popup_erreur(char texte[30]) * \brief Cette fonction affiche une popup en cas d'erreur avec Ã©crit le code d'erreur en question * \param texte[30] Code d'erreur * \return 1 si l'utilisateur souhaite poursuivre malgrÃ© l'erreur ou 0 si arret*/int creation_popup_erreur(char texte[30]){    SDL_Window *popup=SDL_CreateWindow("Erreur detectee !",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,400,100,SDL_WINDOW_SHOWN);    SDL_Renderer *rendu=SDL_CreateRenderer(popup,-1,SDL_RENDERER_SOFTWARE);    chargement_police(TAILLE_POLICE_T7);    SDL_Surface *text=TTF_RenderText_Solid(struct_jeu.police,texte,couleurJaune);    SDL_Surface *surface=SDL_LoadBMP(SRC_IMG_POPUP);    SDL_BlitSurface(text,NULL,surface,NULL);    SDL_Texture *texture=SDL_CreateTextureFromSurface(rendu,surface);    SDL_FreeSurface(surface);    SDL_FreeSurface(text);    SDL_RenderCopy(rendu,texture,NULL,NULL);    SDL_RenderPresent(rendu);    SDL_DestroyTexture(texture);    if(input_popup())    {        SDL_DestroyWindow(popup);        SDL_DestroyRenderer(rendu);        return 1;    }    SDL_DestroyWindow(popup);    SDL_DestroyRenderer(rendu);    return 0;}/** * \fn void chargement_demarrage() * \brief Cette fonction rÃ©alise l'affichage de l'Ã©cran de dÃ©marrage du jeu, en affichant le logo*/void chargement_demarrage(){    SDL_Texture *texture_fond;    SDL_Surface *surface=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0,0,0,0);//Crï¿½ation d'une surface noir permettant de contenir le texte de dï¿½marage du jeu    int w=1920,h=1080;    if(surface==NULL)quitter(SDL_BASE);    texture_fond=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    if(texture_fond==NULL)quitter(SDL_BASE);    if(SDL_RenderCopy(struct_jeu.rendu_fenetre, texture_fond, NULL, NULL))quitter(SDL_BASE);    SDL_RenderPresent(struct_jeu.rendu_fenetre);    //changement de taille de police    chargement_police(TAILLE_POLICE_T1);    SDL_Surface *text1=TTF_RenderText_Blended(struct_jeu.police,"PEPITE DE FIGHT",couleurBlanc);//ï¿½criture du text en gros "T1"    //changement de taille de police    chargement_police(TAILLE_POLICE_T4);    SDL_Surface *text2=TTF_RenderText_Blended(struct_jeu.police,"By GS'corp",couleurBlanc);//ï¿½criture du text en moyen "T3"    SDL_Rect rectDEST_text1= {w*0.15,h*0.33,text1->w,text1->h};    SDL_Rect rectDEST_text2= {w*0.30,h*0.48,text2->w,text2->h};    if(SDL_BlitSurface(text1,NULL,surface,&rectDEST_text1))quitter(SDL_BASE);    if(SDL_BlitSurface(text2,NULL,surface,&rectDEST_text2))quitter(SDL_BASE);    //On libï¿½re la mï¿½moire de la texture et on remet la nouvelle    SDL_DestroyTexture(texture_fond);    texture_fond=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    if(texture_fond==NULL)quitter(SDL_BASE);    //=============    SDL_SetTextureBlendMode(texture_fond, SDL_BLENDMODE_BLEND);    //affichage succesif du text    SDL_Delay(3000);    for(int i=0; i<70; i++)    {        SDL_SetTextureAlphaMod(texture_fond,i);        if(SDL_RenderCopy(struct_jeu.rendu_fenetre, texture_fond, NULL, NULL))quitter(SDL_BASE);        SDL_RenderPresent(struct_jeu.rendu_fenetre);        SDL_Delay(FRAME_RATE_INTRO);    }    SDL_FreeSurface(surface);    SDL_FreeSurface(text1);    SDL_FreeSurface(text2);    SDL_DestroyTexture(texture_fond);}/** * \fn void transition_visuelle() * \brief Pour Ã©viter d'avoir un changement brutale de texture, cette fonction "noirci" la texture afin de rÃ©aliser une transition correcte*/void transition_visuelle(){    SDL_Surface *surface=SDL_GetWindowSurface(struct_jeu.fenetre_jeu);    if(surface==NULL)quitter(SDL_BASE);    SDL_DestroyTexture(struct_jeu.transition);    struct_jeu.transition=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    SDL_FreeSurface(surface);    SDL_SetTextureBlendMode(struct_jeu.transition, SDL_BLENDMODE_BLEND);    for(int i=0; i<10; i++)    {        SDL_SetTextureAlphaMod(struct_jeu.transition,(10-i)*10);        if(SDL_RenderCopy(struct_jeu.rendu_fenetre, struct_jeu.transition, NULL, NULL))quitter(SDL_BASE);        SDL_RenderPresent(struct_jeu.rendu_fenetre);        SDL_Delay(FRAME_TRANSITION);    }}/** * \fn void affichage_accueil() * \brief Cette fonction affiche le la vidÃ©o en arriÃ¨re plan ainsi que le menu de l'accueil*/void affichage_accueil(){    //cette fonction affiche une image de la vidï¿½o de fond puis l'accueil    if(struct_jeu.textures_fond_accueil[struct_jeu.frequence_video]!=NULL)    {        SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_fond_accueil[struct_jeu.frequence_video++],NULL,NULL);        struct_jeu.frequence_video++;        struct_jeu.frequence_video%=100;    }    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.texture_accueil,NULL,NULL);}/** * \fn void afficher_details_parametres() * \brief Selon la page dans les parametres que nous nous trouvons, les informations que dispose le programme doivent Ãªtre affichÃ©s, cette fonction rÃ©alise cette tache.*/void afficher_details_parametres(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,jeu_parametres.tabMenu[jeu_parametres.page],NULL,NULL);    SDL_Surface *text=NULL;    SDL_Surface *surfaceDest=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);    SDL_Rect Rectangle= {0,0,0,0};    SDL_Texture *texture=NULL;    //changement de taille de police    chargement_police(TAILLE_POLICE_T55);    char chaine[20];    memset(chaine,0,sizeof(char)*20);    switch(jeu_parametres.page)    {    case PAGE_GRAPHISMES:        sprintf(chaine,"%d / %d", jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution],jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]);//on convertit en chaine de caractï¿½re la rï¿½solution acctuelle        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);//Appel de la fonction TTF_RenderText pour transformer la "chaine" en surface SDL        Rectangle.x=XRAPPORT_PARA_RE*1920;        Rectangle.y=YRAPPORT_PARA_RE*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient la rï¿½solution        SDL_FreeSurface(text);        if(jeu_parametres.mode)strcpy(chaine,"Plein Ecran");        else strcpy(chaine,"FenÃªtre");        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);        Rectangle.x=XRAPPORT_PARA_MA*1920;        Rectangle.y=YRAPPORT_PARA_MA*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient le mode d'affichage        SDL_FreeSurface(text);        sprintf(chaine,"%d", jeu_parametres.plageFPS[jeu_parametres.fps]);//on convertit en chaine de caractÃ¨re les fps max        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);        Rectangle.x=XRAPPORT_PARA_FPS*1920;        Rectangle.y=YRAPPORT_PARA_FPS*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient les fps        if(jeu_parametres.affichFPS)        {            SDL_FreeSurface(text);            text=IMG_Load(SRC_IMG_CHECK);            Rectangle.x=2+XRAPPORT_BOUTON_AFPS*1920;            Rectangle.y=2+YRAPPORT_BOUTON_AFPS*1080;            Rectangle.h=text->h;            Rectangle.w=text->w;            SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient l'image check pour montrer a l'utilisateur que le programme affiche les fps        }        texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surfaceDest);        if(texture==NULL)quitter(SDL_BASE);        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);        SDL_FreeSurface(text);        SDL_DestroyTexture(texture);        break;    case PAGE_INTERFACE:        break;    case PAGE_AUDIO:        //pour la musique        Rectangle.x=1+XRAPPORT_CUR_MUS*1920;        Rectangle.y=1+YRAPPORT_CUR_MUS*1080;        Rectangle.h=(YMAXRAPPORT_CUR_MUS*1080-YRAPPORT_CUR_MUS*1080);        Rectangle.w=(jeu_parametres.musique*0.01)*(int)((XMAXRAPPORT_CUR_MUS-XRAPPORT_CUR_MUS)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        //pour les effets sonores        Rectangle.x=1+XRAPPORT_CUR_EFS*1920;        Rectangle.y=1+YRAPPORT_CUR_EFS*1080;        Rectangle.h=(YMAXRAPPORT_CUR_EFS*1080-YRAPPORT_CUR_EFS*1080);        Rectangle.w=(jeu_parametres.effets*0.01)*(int)((XMAXRAPPORT_CUR_EFS-XRAPPORT_CUR_EFS)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        //pour les dialogues        Rectangle.x=1+XRAPPORT_CUR_DIA*1920;        Rectangle.y=1+YRAPPORT_CUR_DIA*1080;        Rectangle.h=(YMAXRAPPORT_CUR_DIA*1080-YRAPPORT_CUR_DIA*1080);        Rectangle.w=(jeu_parametres.dialogues*0.01)*(int)((XMAXRAPPORT_CUR_DIA-XRAPPORT_CUR_DIA)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        if(jeu_parametres.arriere_plan)        {            text=IMG_Load(SRC_IMG_CHECK);            Rectangle.x=2+XRAPPORT_BOUTON_SAP*1920;            Rectangle.y=2+YRAPPORT_BOUTON_SAP*1080;            Rectangle.h=text->h;            Rectangle.w=text->w;            SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient l'image check pour montrer ï¿½ l'utilisateur que le programme affiche les fps            SDL_FreeSurface(text);        }        texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surfaceDest);        if(texture==NULL)quitter(SDL_BASE);        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);        SDL_DestroyTexture(texture);        break;    case PAGE_CONTROLES:        break;    }    SDL_FreeSurface(surfaceDest);}/** * \fn void affichage_fps() * \brief Comme dans tous jeu de "baston" on peut Ãªtre ammenÃ© Ã  quel frÃ©quence le programme "tourne", cette fonction affiche les fps moyen, min et max si le joueur Ã  choisi de les afficher*/void affichage_fps(){    if(jeu_parametres.affichFPS)    {        char chaine[20];        sprintf(chaine,"FPS:%d, max:%d min:%d",struct_jeu.fpsMoy,struct_jeu.fpsMax,struct_jeu.fpsMin);        //changement de taille de police        chargement_police(TAILLE_POLICE_T8);        SDL_Surface *text=TTF_RenderText_Solid(struct_jeu.police,chaine,couleurBlanc);        SDL_Texture *texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,text);        SDL_Rect position= {0,0,text->w,text->h};        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,&position);        SDL_FreeSurface(text);        SDL_DestroyTexture(texture);    }}/** * \fn void rendre_affichage() * \brief Pour Ã©viter de se mÃ©langer les pinceaux, cette fonction rÃ©alise l'affichage du rendu, comme en SDL les textures sont superposÃ©es comme des calques, cette fonction affichera le sommet du calque */void rendre_affichage(){    SDL_RenderPresent(struct_jeu.rendu_fenetre);}/** * \fn void afficher_partie() * \brief Cette fonction affiche le fond d'Ã©cran de la partie ainsi que les plateformes, celles ci sont sÃ©lectionnÃ©es dans les paramÃªtres */void afficher_partie(){    /*Pour l'instant la fonction fait juste render_copy mais ï¿½ l'avenir cette fonction calculera la surface de la texture ï¿½ afficher     *     */    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_fond_jeu[struct_jeu.texture_fond_jeu_selectione],NULL,NULL);    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_plateau_jeu[struct_jeu.texture_plateau_jeu_selectione],NULL,NULL);}/** * \fn void afficher_joueurs() * \brief En fonction des textures sÃ©lÃ©ctionnÃ©es par le joueur, le programme durant la partie va afficher les joueurs grÃ¢ce Ã  cette fonction */void afficher_joueurs(){    SDL_Rect position_Final= {0,0,(int)(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_LARGEUR_PERSO),(int)(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_HAUTEUR_PERSO)};    SDL_RendererFlip flip = SDL_FLIP_VERTICAL;    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        position_Final.x=((struct_jeu.joueurs[i].positionX)*(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution])/1920)-jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_OFFSET_X;        position_Final.y=((struct_jeu.joueurs[i].positionY)*(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution])/1080)-jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_OFFSET_Y;        position_Final.h=(int)(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_Y_PERSO);        position_Final.w=(int)(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_X_PERSO);        if(struct_jeu.joueurs[i].direction==DROITE)        {            if(SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_personnages_joueurs[i][struct_jeu.joueurs[i].etat][struct_jeu.frames_evolution%10],NULL,&position_Final) <0)quitter(SDL_BASE);        }        else        {            if(SDL_RenderCopyEx(struct_jeu.rendu_fenetre,struct_jeu.textures_personnages_joueurs[i][struct_jeu.joueurs[i].etat][struct_jeu.frames_evolution%10],NULL,&position_Final,180,NULL,flip) <0)quitter(SDL_BASE);        }    }}/** * \fn void afficher_vie_joueurs() * \brief Les personnages ont une bare de vie, donc Ã  tout moment le joueur est ammenÃ© Ã  savoir combien de vie a son personnage, cette fonction affiche Ã  l'Ã©cran la vie de tous les joueurs*/void afficher_vie_joueurs(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.vie_joueurs,NULL,NULL);    SDL_Surface *surface=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);    SDL_Texture *texture=NULL;    SDL_Rect Rectangle= {0,RAPPORT_Y_VIE*1080,0,RAPPORT_H_VIE*1080};    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        Rectangle.x=tab_rapport_X_vies[i]*1920;        Rectangle.w=((RAPPORT_H_VIE-Rectangle.x)*1920)*(struct_jeu.joueurs[i].vie/100);        switch(i)        {        case J1:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 255, 0, 0));            break;        case J2:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 255, 255, 0));            break;        case J3:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 0, 0, 255));            break;        case J4:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 0, 255, 0));            break;        }    }    texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);    SDL_FreeSurface(surface);    SDL_DestroyTexture(texture);}/** * \fn void afficher_ecran_multijoueur() * \brief Une fois le mode multijoueur sÃ©lÃ©ctionnÃ©, le joueur est ammenÃ© Ã  selectionner un mode "2j/4J :: local / rÃ©seau", cette fonction affiche Ã  l'Ã©cran des cases oÃ¹ cliquer pour selectionner ce mode */void afficher_ecran_multijoueur(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.texture_multijoueur,NULL,NULL);}/** * \fn void afficher_pause() * \brief Si le(s) joueur(s) est(sont) en local, il y a la possibilitÃ© de mettre pause, cette fonction affiche le menu pause */void afficher_pause(){}/** * \fn void modifier_window() * \brief Lorsque l'utilisateur est dans les paramÃ¨tres du jeu, il peut Ãªtre ammenÃ© Ã  modifier la taille de sa fenÃªtre, cette fonction regroupe toutes les fonctions rÃ©alisant ce changement */void modifier_window(){    if(jeu_parametres.mode)    {        SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_FULLSCREEN_DESKTOP);        SDL_GetWindowSize(struct_jeu.fenetre_jeu,&jeu_parametres.reso[0][9],&jeu_parametres.reso[1][9]);    }    else    {        SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_SHOWN);        SDL_SetWindowSize(struct_jeu.fenetre_jeu,jeu_parametres.reso[0][jeu_parametres.resolution], jeu_parametres.reso[1][jeu_parametres.resolution]);        SDL_SetWindowPosition(struct_jeu.fenetre_jeu,SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED);    }}/** * @file        input.c * @brief       Contient l'implÃ©mentation des fonctions d'Ã©vÃ©nements ainsi que de jeu * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/input.h"/** * \fn int input_popup() * \brief Cette fonction gÃ¨re l'entrÃ©e des Ã©vÃ©nements de la popup d'erreur, dans le cas oÃ¹ une erreur survient (cf : quitter() -> init.c) * * \return RETOUR_QUITTER si l'utilisateur veut mettre fin au programme ou RETOUR_POURSUIVRE s'il souhaite poursuivre malgrÃ© l'erreur */int input_popup(){    SDL_Event event;    while(1)    {        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=XPOURSUIVRE_MIN && event.button.x<=XPOURSUIVRE_MAX && event.button.y>=YPOURSUIVRE_MIN && event.button.y<=YPOURSUIVRE_MAX)                    return RETOUR_POURSUIVRE;                if(event.button.x>=XQUITTER_MIN && event.button.x<=XQUITTER_MAX && event.button.y>=YQUITTER_MIN && event.button.y<=YQUITTER_MAX)                    return RETOUR_QUITTER;                break;//pour faire joli            case SDL_QUIT:                return RETOUR_QUITTER;                break;//pour faire joli            }        delay();    }    return RETOUR_QUITTER;}/** * \fn void accueil() * \brief Cette fonction gÃ¨re l'entrÃ©e des Ã©vÃ©nements de l'accueil, c'est la fonction principale du programme, elle permet Ã  l'utilisateur d'accÃ©der au diffÃ©rents modes de jeu ainsi qu'aux paramÃ¨tres et de quitter * */void accueil(){    //on clear le visuel    transition_visuelle();    //on met la musique    chargement_musique(0,MUSIQUE_ACCUEIL,INFINI);    SDL_Event event;    SDL_bool continuer=SDL_TRUE;    while(continuer)    {        affichage_accueil();        affichage_fps();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                quitter(QUITTER);                break;            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTONS_ACCUEIL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTONS_ACCUEIL) //si on se situe dans l'interval graphique des boutons                {                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CAMPAGNE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CAMPAGNE) //Appuis du bouton Campagne par l'utilisateur                    {                        campagne();                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_MULTIJOUEUR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_MULTIJOUEUR) //Appuis du bouton Campagne par l'utilisateur                    {                        struct_jeu.nombre_joueurs=multijoueur();                        if(struct_jeu.reseauOn)choix_serveur();                        if(struct_jeu.nombre_joueurs)choix_personnage();                        if(struct_jeu.nombre_joueurs)partie();                        struct_jeu.nombre_joueurs=0;                        struct_jeu.reseauOn=0;                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_PARAMETRES && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_PARAMETRES) //Appuis du bouton Campagne par l'utilisateur                    {                        menu_parametre();                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_QUITTER && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_QUITTER) //Appuis du bouton Quitter par l'utilisateur                    {                        quitter(QUITTER);                    }                }                break;            case SDL_WINDOWEVENT:                if(!jeu_parametres.arriere_plan)                {                    switch(event.window.event)                    {                    case SDL_WINDOWEVENT_MINIMIZED:                        struct_jeu.focus_loose=1;                        break;                    case SDL_WINDOWEVENT_MAXIMIZED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_GAINED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_LOST:                        struct_jeu.focus_loose=1;                        break;                    }                    changement_volumes_musiques();                }                break;            }        delay();    }}/** * \fn void menu_parametre() * \brief Cette fonction gÃ¨re l'entrÃ©e des Ã©vÃ©nements du menu des parametre, cette fonction permet Ã  l'utilisateur grÃ¢ce Ã  l'interface graphique de changer ses controles, ses fps etc... * */void menu_parametre(){    int buffer;    SDL_Event event;    while(1)    {        afficher_details_parametres();        affichage_fps();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                sauvegarde_parametres();                quitter(QUITTER);                break;            case SDL_MOUSEBUTTONDOWN:                if(event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]/RAPPORT_PARAMETRE_CHOIX) //Selection du menu en question (parametre / audio / . . .                {                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_GRAPHISMES && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_GRAPHISMES)                        jeu_parametres.page=0;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_JOUABILITE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_JOUABILITE)                        jeu_parametres.page=1;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_INTERFACE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_INTERFACE)                        jeu_parametres.page=2;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_SOURISCLAVIER && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_SOURISCLAVIER)                        jeu_parametres.page=3;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_MANETTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_MANETTE)                        jeu_parametres.page=4;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_AUDIO && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_AUDIO)                        jeu_parametres.page=5;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_CONTROLES && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_CONTROLES)                        jeu_parametres.page=6;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_CONTROLESMANETTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_CONTROLESMANETTE)                        jeu_parametres.page=7;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_COMPTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_COMPTE)                        jeu_parametres.page=8;                }                switch(jeu_parametres.page)                {                case PAGE_GRAPHISMES:                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_MA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_MA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_MA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_MA)                    {                        jeu_parametres.mode=0;                        modifier_window();                    }//si on appuis sur le bouton (-) pour le mode d'affichage                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BP_MA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BP_MA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BP_MA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BP_MA)                    {                        jeu_parametres.mode=1;                        modifier_window();                    }//si on appuis sur le bouton (+) pour le mode d'affichage                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_RE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_RE && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_RE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_RE && !jeu_parametres.mode)                    {                        if(jeu_parametres.resolution>0)                        {                            jeu_parametres.resolution--;                            modifier_window();                        }                    }//si on appuis sur le bouton (-) pour la rï¿½solution                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.resolution]*XRAPPORT_BP_RE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.resolution]*XMAXRAPPORT_BP_RE && event.button.y>=jeu_parametres.reso[1][jeu_parametres.resolution]*YRAPPORT_BP_RE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.resolution]*YMAXRAPPORT_BP_RE && !jeu_parametres.mode)                    {                        if(jeu_parametres.resolution<8)                        {                            jeu_parametres.resolution++;                            modifier_window();                        }                    }//si on appuis sur le bouton (+) pour la rï¿½solution                    if(jeu_parametres.mode)                    {                        if(event.button.x>=jeu_parametres.reso[0][9]*XRAPPORT_BM_MA && event.button.x<=jeu_parametres.reso[0][9]*XMAXRAPPORT_BM_MA && event.button.y>=jeu_parametres.reso[1][9]*YRAPPORT_BM_MA && event.button.y<=jeu_parametres.reso[1][9]*YMAXRAPPORT_BM_MA)                        {                            if(jeu_parametres.mode>0)                            {                                jeu_parametres.mode--;                                modifier_window();                            }                        }//si on appuis sur le bouton (-) pour le mode d'affichage et qu'on est en mode plein ï¿½cran                    }                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_FPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_FPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_FPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_FPS)                    {                        if(jeu_parametres.fps>0)                        {                            jeu_parametres.fps--;                            modifier_window();                        }                    }//si on appuis sur le bouton (-) pour les FPS                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BP_FPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BP_FPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BP_FPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BP_FPS)                    {                        if(jeu_parametres.fps<5)                        {                            jeu_parametres.fps++;                            modifier_window();                        }                    }//si on appuis sur le bouton (+) pour les FPS;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_AFPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_AFPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_AFPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_AFPS)                    {                        if(jeu_parametres.affichFPS)jeu_parametres.affichFPS=0;                        else jeu_parametres.affichFPS=1;                    }//si on appuis sur le bouton pour afficher les FPS;                    break;                case PAGE_INTERFACE:                    break;                case PAGE_AUDIO:                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_MUS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_MUS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_MUS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_MUS)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_MUS*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_MUS-XRAPPORT_CUR_MUS)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.musique=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur de la musique                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_EFS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_EFS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_EFS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_EFS)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_EFS*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_EFS-XRAPPORT_CUR_EFS)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.effets=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur des effets sonores                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_DIA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_DIA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_DIA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_DIA)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_DIA*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_DIA-XRAPPORT_CUR_DIA)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.dialogues=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur des effets sonores                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_SAP && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_SAP && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_SAP && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_SAP && jeu_parametres.dialogues<100)                    {                        if(jeu_parametres.arriere_plan)jeu_parametres.arriere_plan=0;                        else jeu_parametres.arriere_plan=1;                    }//si on appuis sur le bouton pour activer les sons en arriï¿½re plan                    changement_volumes_musiques();                    break;                case PAGE_CONTROLES:                    break;                }                if(event.button.y>=YRAPPORT_BOUTON_VALID*jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_VALID)                {                    if(event.button.x>=XRAPPORT_BOUTON_RESET*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_RESET)                    {                        remove(SRC_FICHIER_PARA);                        chargement_parametres();                        modifier_window();                        changement_volumes_musiques();                    }                    if(event.button.x>=XRAPPORT_BOUTON_BACK*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_BACK)                    {                        changement_volumes_musiques();                        sauvegarde_parametres();                        return;                    }                }//boutons de validation appuis ï¿½ la souris                break;            case SDL_KEYDOWN:                switch(event.key.keysym.sym)                {                case SDLK_r:                    remove(SRC_FICHIER_PARA);                    chargement_parametres();                    changement_volumes_musiques();                    sauvegarde_parametres();                    break;                case SDLK_ESCAPE:                    changement_volumes_musiques();                    sauvegarde_parametres();                    return;                }                break;            case SDL_WINDOWEVENT:                if(!jeu_parametres.arriere_plan)                {                    switch(event.window.event)                    {                    case SDL_WINDOWEVENT_MINIMIZED:                        struct_jeu.focus_loose=1;                        break;                    case SDL_WINDOWEVENT_MAXIMIZED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_GAINED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_LOST:                        struct_jeu.focus_loose=1;                        break;                    }                    changement_volumes_musiques();                }                break;            }        delay();    }}/** * \fn void campagne() * \brief Cette fonction gÃ¨re les Ã©vÃ©nements de du menu campagne pour une Ã©ventuelle partie en solo * */void campagne(){}/** * \fn int multijoueur() * \brief Contrairement Ã  campagne la fonction multijoueur permet de rÃ©cupÃ©rer la faÃ§on dont une partie va se dÃ©roulÃ©, elle permet Ã©galement de savoir si une partie va se dÃ©rouler en rÃ©seau ou non * * \return nombre_joueurs (2/4) ou 0 si abandon */int multijoueur(){    transition_visuelle();    afficher_ecran_multijoueur();    rendre_affichage();    SDL_Event event;    while(1)    {        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_KEYDOWN:                if(event.key.keysym.sym == SDLK_ESCAPE)                    return 0;            case SDL_QUIT:                quitter(QUITTER);            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_2JL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_2JL && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_2JL && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_2JL)                {                    struct_jeu.reseauOn=0;                    return 2;                }//si on appuis sur le bouton 2 J local                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_4JL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_4JL && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_4JL && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_4JL)                {                    struct_jeu.reseauOn=0;                    return 4;                }//si on appuis sur le bouton 4 J local                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_2JR && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_2JR && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_2JR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_2JR)                {                    struct_jeu.reseauOn=1;                    return 2;                }//si on appuis sur le bouton 2 J reseau                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_4JR && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_4JR && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_4JR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_4JR)                {                    struct_jeu.reseauOn=1;                    return 4;                }//si on appuis sur le bouton 4 J reseau                break;            }    }    return 0;}/** * \fn void partie() * \brief La fonction coeur du jeu, elle permet de faire une partie du jeu en multijoueur, cette fonction rÃ©cupÃ¨res les actions des joueurs et appels les fonctions d'actions.c pour mouvoir, faire attacker les joueurs * * */void partie(){    transition_visuelle();    SDL_Event event;    for(;;)    {        afficher_partie();        afficher_joueurs();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                quitter(QUITTER);                break;            case SDL_KEYDOWN:                if(event.key.keysym.sym == jeu_parametres.avancer1)struct_jeu.tableau_event[J1][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer2)struct_jeu.tableau_event[J2][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer3)struct_jeu.tableau_event[J3][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer4)struct_jeu.tableau_event[J4][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer1)struct_jeu.tableau_event[J1][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer2)struct_jeu.tableau_event[J2][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer3)struct_jeu.tableau_event[J3][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer4)struct_jeu.tableau_event[J4][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter1)struct_jeu.tableau_event[J1][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter2)struct_jeu.tableau_event[J2][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter3)struct_jeu.tableau_event[J3][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter4)struct_jeu.tableau_event[J4][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer1)struct_jeu.tableau_event[J1][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer2)struct_jeu.tableau_event[J2][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer3)struct_jeu.tableau_event[J3][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer4)struct_jeu.tableau_event[J4][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe1)struct_jeu.tableau_event[J1][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe2)struct_jeu.tableau_event[J2][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe3)struct_jeu.tableau_event[J3][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe4)struct_jeu.tableau_event[J4][4]=TRUE;                if(event.key.keysym.sym == SDLK_ESCAPE)pause();                break;            case SDL_KEYUP:                if(event.key.keysym.sym == jeu_parametres.avancer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][4]=FALSE;                }                break;            }        action_timer();        affichage_fps();        delay();    }}/** * \fn void choix_serveur() * \brief Cette fonction permet de rÃ©cupÃ¨rer l'ip du serveur sur lequel une Ã©ventuelle partie en rÃ©seau se dÃ©roulerais * * */void choix_serveur(){}/** * \fn void choix_personnage() * \brief Cette fonction permet de savoir quel personnage chaque joueur va jouer * * */void choix_personnage(){    transition_visuelle();    struct_jeu.joueurs[0].type_personnage=01;    struct_jeu.joueurs[1].type_personnage=02;    for(int i=0; i<4; i++) //on remplit les structures des joueurs avec les valeurs adï¿½quats restantes    {        struct_jeu.joueurs[i].vie=INIT_VIE;        struct_jeu.joueurs[i].evolution=0;        struct_jeu.joueurs[i].etat=IDLE;        struct_jeu.joueurs[i].direction=(i%2?GAUCHE:DROITE);//le(s) joueur(s) 1( et 3) est(sont) contre(s) le(s) joueur(s) 2(et 4)        struct_jeu.joueurs[i].positionY=1030;    }    struct_jeu.joueurs[0].positionX=410;//JOUEUR 1    struct_jeu.joueurs[1].positionX=1560;//JOUEUR 2    struct_jeu.joueurs[2].positionX=530;//JOUEUR 3    struct_jeu.joueurs[3].positionX=1440;//JOUEUR 4    creation_textures_personnage();}/** * \fn void choix_personnage() * \brief Cette fonction permet de faire une pause tant que l'utilisateur n'a pas appuyer sur echape, elle n'est pas dans timer.c car elle n'agit pas directement sur le temps, elle fait une sorte de boucle sans changer l'affichage. Ps: disponible uniquement en local */void pause(){    if(!struct_jeu.reseauOn)    {        afficher_pause();        SDL_Event event;        while(1)        {            while(SDL_PollEvent(&event))                switch(event.type)                {                case SDL_QUIT:                    quitter(QUITTER);                    break;                case SDL_KEYDOWN:                    if(event.key.keysym.sym == SDLK_ESCAPE)return;                }            delay();        }    }}/** * @file        sockets.c * @brief       Contient l'implÃ©mentation des fonctions de rÃ©seau pour jouer en multijoueur * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/sockets.h"/** * \fn void initialisation_socket() * \brief Cette fonction permet d'initialiser les paramÃ¨tres de la socket */void initialisation_socket(){    memset(&(sockets.adresse_serveur),0,sizeof(sockets.adresse_serveur));    sockets.adresse_serveur.sin_port = htons(30000);    sockets.adresse_serveur.sin_family = AF_INET;    sockets.adresse_serveur.sin_addr.s_addr = htonl(INADDR_ANY);}/** * \fn int hostname_to_ip(char * hostname , char* ip) * \brief Cette fonction transforme un hostname en ip "claire" pour le programme * return 0 si aucune erreur */int hostname_to_ip(char * hostname , char* ip){    struct hostent *he;    struct in_addr **addr_list;    int i;    if ( (he = gethostbyname( hostname ) ) == NULL)quitter(RESEAU);    addr_list = (struct in_addr **) he->h_addr_list;    for(i = 0; addr_list[i] != NULL; i++)    {        //Return the first one;        strcpy(ip , inet_ntoa(*addr_list[i]) );        return 0;    }    return 1;}/** * \fn void creation_socket(char *hostname) * \brief Cette fonction permet de crÃ©er la socket qui Ã©couteras sur le rÃ©seau les packets de donnÃ©es */void creation_socket(char *hostname){    memset(sockets.buffer,0,sizeof(char)*SIZE_BUFFER);    char ip[100];    hostname_to_ip(hostname, ip);    if ((sockets.socket_serveur =socket(AF_INET,SOCK_STREAM,0))== -1)        quitter(RESEAU);    /* bind serveur - socket */    bind(sockets.socket_serveur,(struct sockaddr *)&sockets.adresse_serveur,sizeof(sockets.adresse_serveur));    /* ecoute sur la socket */    listen(sockets.socket_serveur,5);    sockets.mon_address_longueur = sizeof(sockets.adresse_serveur);}/** * \fn void connexion_client() * \brief Cette fonction bloquante, permet d'attendre qu'un client (autre pc) se connect au serveur(ce pc) */void connexion_client(){    /* on attend que le client se connecte */    sockets.socket_client = accept(sockets.socket_serveur,(struct sockaddr *)&(sockets.socket_client),&(sockets.mon_address_longueur));}/** * \fn void lire_socket() * \brief Cette fonction traite les donnÃ©es prÃ©sentes sur la socket */void lire_socket(){    memset(sockets.buffer,0,sizeof(char)*SIZE_BUFFER);    recv(sockets.socket_client, sockets.buffer, sizeof(sockets.buffer),0);    if(sockets.buffer[0]=='$')    {        int i=1;        for(int y=0; y<5; y++)        {            struct_jeu.tableau_event[J2][y]=sockets.buffer[i++];        }        for(int y=0; y<5; y++)        {            struct_jeu.tableau_event[J4][y]=sockets.buffer[i++];        }    }}/** * \fn void ecrire_socket() * \brief Cette fonction permet d'envoyer des donnÃ©es sur la socket */void ecrire_socket() //struct_jeu.tableau_event[J2/J4][0->4]{    sockets.buffer[0]='$';    int i=1;    for(int y=0; y<5; y++)    {        sockets.buffer[i++]=struct_jeu.tableau_event[J2][y];    }    for(int y=0; y<5; y++)    {        sockets.buffer[i++]=struct_jeu.tableau_event[J4][y];    }    send(sockets.socket_serveur,sockets.buffer,sizeof(sockets.buffer),0);}/** * \fn void destruction_socket() * \brief Cette fonction met fin Ã  la socket, elle libÃ¨re l'espace */void destruction_socket(){    shutdown(sockets.socket_serveur,2);    close(sockets.socket_serveur);}/** * @file        actions.h * @brief       Contient les dÃ©clarations des fonctions d'actions des joueurs * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __ACTIONS__#define __ACTIONS__#include "struct.h"void pesanteur();void avancer();void sauter();void attaquer();void coupspe();void repos();#endif // __ACTIONS__/** * @file        draw.h * @brief       Contient les dÃ©clarations des fonctions d'affichage * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __DRAW__#define __DRAW__#include "struct.h"/*  FONCTIONS   */void definir_resolutions();void chargerTextures();void creation_textures_personnage();void destruction_textures_personnage();void creation_fenetre();int creation_popup_erreur(char texte[30]);void chargement_demarrage();void transition_visuelle();void affichage_accueil();void afficher_details_parametres();void affichage_fps();void rendre_affichage();void afficher_partie();void afficher_joueurs();void afficher_vie_joueurs();void afficher_ecran_multijoueur();void afficher_pause();void modifier_window();#endif // __DRAW__/** * @file        input.h * @brief       Contient les dÃ©clarations des fonctions d'Ã©vÃ©nements * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __INPUT__#define __INPUT__#include "struct.h"int input_popup();void accueil();void menu_parametre();void campagne();int multijoueur();void partie();void choix_serveur();void choix_personnage();void pause();#endif // __INPUT__/** * @file        sockets.h * @brief       Contient les dÃ©clarations des fonctions liÃ©es au rÃ©seau * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __SOCKETS__#define __SOCKETS__#include "struct.h"/*  FONCTIONS   */void initialisation_socket();int hostname_to_ip(char * hostname , char* ip);void creation_socket(char *hostname);void connexion_client();void lire_socket();void ecrire_socket();void destruction_socket();#endif // __SOCKETS__/** * @file        init.c * @brief       Contient l'implÃ©mentation des fonctions d'initialisation, comme la police, les variables, les structures . . . * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/init.h"/** * \fn void initialisation_parametres() * \brief Cette fonction permet d'initialiser la plupart des structures et d'appeler les fonctions pour crÃ©er la fenetre, lancer l'Ã©cran de chargement et rÃ©cupÃ©rer les parametres utilisateur comme les contrÃ´les */void initialisation_parametres(){    //Rï¿½cupï¿½rations des parametres (controls,...)    chargement_parametres();    initialisation_fps();    struct_jeu.ticks_depart=SDL_GetTicks();    struct_jeu.ticks_evo=struct_jeu.ticks_depart;    struct_jeu.ticks_actions=struct_jeu.ticks_depart;    //Dï¿½marrage des fonctions nï¿½cï¿½ssaires ï¿½ l'affichage    definir_resolutions();    creation_fenetre();    modifier_window();    //chargement des textures    chargerTextures();    struct_jeu.frequence_video=0;//on initialise la variable qui gï¿½re les textures de fond de vidï¿½o d'accueil    struct_jeu.texture_fond_jeu_selectione=2;    struct_jeu.texture_plateau_jeu_selectione=0;    //Chargement de la police    chargement_police(TAILLE_POLICE_T1);    //Chargement de la musique d'intro    creation_canaux_musique();    chargement_musique(6,MUSIQUE_INTRO,0);    changement_volumes_musiques();    //affichage de l'ï¿½cran de chargement (dï¿½marrage)    chargement_demarrage();    detruire_musique(MUSIQUE_INTRO);}/** * \fn void chargement_police(int taille) * \brief Cette fonction permet de chnager la taille de la police (cf defs.h -> diffÃ©rentes tailles de police) * \param taille Correspond Ã  la taille choisie */void chargement_police(int taille){    TTF_CloseFont(struct_jeu.police);    struct_jeu.police=NULL;    struct_jeu.police=TTF_OpenFont(POLICE,taille);    if(struct_jeu.police==NULL)quitter(SDL_TTF);}/** * \fn void chargement_parametres() * \brief Cette fonction permet de sois crÃ©Ã©er le fichier de sauvegarde des parametres sois de rÃ©cupÃ©rer les parametres sauvegardÃ©s */void chargement_parametres() //Cette fonction ï¿½ pour but de rï¿½cupï¿½rer les contrï¿½les sauvegardï¿½s; Si jamais des contrï¿½les sont perdu ou inï¿½xistants, la fonction remet/met par dï¿½fault des contrï¿½les{    FILE *f_parametres=NULL;    f_parametres=fopen(SRC_FICHIER_PARA,"r");    if(errno==2) //si fichier introuvable alors crï¿½ation du fichier    {        fclose(f_parametres);        f_parametres=fopen(SRC_FICHIER_PARA,"w");        fprintf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : %d\nAttaquer : %d\nCoupSpe : %d\n", DEF_MODE, DEF_RESO, DEF_FPS, DEF_AFFPS, DEF_ECHELLE, DEF_SOUND,DEF_SOUND, DEF_SOUND, 1, DEF_AVANCER1, DEF_RECULER1, DEF_SAUTER1, DEF_ATTAQUE1, DEF_ATTAQUESPE1, DEF_AVANCER2, DEF_RECULER2, DEF_SAUTER2, DEF_ATTAQUE2, DEF_ATTAQUESPE2, DEF_AVANCER3, DEF_RECULER3, DEF_SAUTER3, DEF_ATTAQUE3, DEF_ATTAQUESPE3, DEF_ATTAQUE4, DEF_RECULER4, DEF_SAUTER4, DEF_ATTAQUE4, DEF_ATTAQUESPE4);        fclose(f_parametres);        f_parametres=fopen(SRC_FICHIER_PARA,"r");    }    fscanf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : %d\nAttaquer : %d\nCoupSpe : %d\n", &jeu_parametres.mode, &jeu_parametres.resolution, &jeu_parametres.fps, &jeu_parametres.affichFPS, &jeu_parametres.echelle, &jeu_parametres.musique, &jeu_parametres.effets, &jeu_parametres.dialogues, &jeu_parametres.arriere_plan, &jeu_parametres.avancer1, &jeu_parametres.reculer1, &jeu_parametres.sauter1, &jeu_parametres.attaquer1, &jeu_parametres.coupspe1, &jeu_parametres.avancer2, &jeu_parametres.reculer2, &jeu_parametres.sauter2, &jeu_parametres.attaquer2, &jeu_parametres.coupspe2, &jeu_parametres.avancer3, &jeu_parametres.reculer3, &jeu_parametres.sauter3, &jeu_parametres.attaquer3, &jeu_parametres.coupspe3, &jeu_parametres.avancer4, &jeu_parametres.reculer4, &jeu_parametres.sauter4, &jeu_parametres.attaquer4, &jeu_parametres.coupspe4);    fclose(f_parametres);}/** * \fn void sauvegarde_parametres() * \brief Cette fonction permet de sauvegarder les parametres utilisateur dans le fichier de sauvegarde */void sauvegarde_parametres(){    FILE *f_parametres=NULL;    f_parametres=fopen(SRC_FICHIER_PARA,"w");    fprintf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n", jeu_parametres.mode, jeu_parametres.resolution, jeu_parametres.fps, jeu_parametres.affichFPS, jeu_parametres.echelle, jeu_parametres.musique, jeu_parametres.effets, jeu_parametres.dialogues, jeu_parametres.arriere_plan, jeu_parametres.avancer1, jeu_parametres.reculer1, jeu_parametres.sauter1, jeu_parametres.attaquer1, jeu_parametres.coupspe1, jeu_parametres.avancer2, jeu_parametres.reculer2, jeu_parametres.sauter2, jeu_parametres.attaquer2, jeu_parametres.coupspe2, jeu_parametres.avancer3, jeu_parametres.reculer3, jeu_parametres.sauter3, jeu_parametres.attaquer3, jeu_parametres.coupspe3, jeu_parametres.avancer4, jeu_parametres.reculer4, jeu_parametres.sauter4, jeu_parametres.attaquer4, jeu_parametres.coupspe4);    fclose(f_parametres);}/** * \fn void quitter(int code) * \brief Cette fonction permet de terminer le programme en faisant apparaitre une popup permettant Ã  l'utilisateur de sois mettre fin au programme sois poursuivre malgrÃ© l'erreur * \param code Corrrespond au code d'erreur d'appel de la fonction (cf defs.h -> code d'erreurs) */void quitter(int code){    char erreur[30];    switch(code)    {    case QUITTER    :        strcpy(erreur,"Programme Quit");        break;    case FOPEN_ERR  :        strcpy(erreur,strerror(errno));        break;    case SDL_IMAGE  :        strcpy(erreur,IMG_GetError());        break;    case SDL_BASE   :        strcpy(erreur,SDL_GetError());        break;    case SDL_TTF    :        strcpy(erreur,TTF_GetError());        break;    case SDL_MIXER  :        strcpy(erreur,Mix_GetError());        break;    case RESEAU     :        strcpy(erreur,"RÃ©seau/socket");        break;    default         :        strcpy(erreur,"default code NULL");        break;    }    fprintf ( stdout,"\nErreur : %s \n", erreur); //on ï¿½crit l'erreur dans le terminal    if(code == QUITTER || !creation_popup_erreur(erreur)) //si la fonction creation_popup renvoie 0 alors l'utilisateur ï¿½ dï¿½cidï¿½ de mettre fin au programme le code QUITTER permet de mettre dï¿½fï¿½nitivement fin au programme sans demandï¿½ ï¿½ l'utilisateur (exemple : bouton quitter dans l'accueil)    {        Mix_CloseAudio();        TTF_CloseFont(struct_jeu.police);        SDL_Quit();        IMG_Quit();        TTF_Quit();        abort();    }}/** * @file        init.h * @brief       Contient les dÃ©clarations des fonctions d'initialisation * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __INIT__#define __INIT__#include "struct.h"/*      FONCTIONS       */void initialisation_parametres();void chargement_police(int taille);void chargement_parametres();void sauvegarde_parametres();void quitter(int code);#endif // __INIT__/** * @file        sounds.h * @brief       Contient les dÃ©clarations des fonctions de son * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __SOUNDS__#define __SOUNDS__#include "struct.h"void creation_canaux_musique();void chargement_musique(int channel, int extra,int rep);void changement_volumes_musiques();void detruire_musique(int extra);#endif // __SOUNDS__/** * @file        timer.h * @brief       Contient les dÃ©clarations des fonctions de temps * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#ifndef __TIMER__#define __TIMER__#include "struct.h"/*  FONCTIONS   */void delay();void relever_fps();void action_timer();void initialisation_fps();#endif // __TIMER__/** * @file        timer.c * @brief       Contient l'implÃ©mentation des fonctions de temps, SDL_Delay . . . * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans UniversitÃ© */#include "include/timer.h"/** * \fn void delay() * \brief Cette fonction effectue une pause dans le programme pour faire correpondre les images affichÃ©es par le programme aux fps demandÃ©es par l'utilisateur (si le joueurs demande 60fps alors le programme ne devra faire une seule boucle par 16ms) */void delay(){    struct_jeu.tableau_fps[struct_jeu.frames_evolution%20]=1000/((struct_jeu.ticks_fin-struct_jeu.ticks_depart)?(struct_jeu.ticks_fin-struct_jeu.ticks_depart):1);    if(struct_jeu.frames_evolution%20)relever_fps();    struct_jeu.ticks_fin=SDL_GetTicks();    int difference=struct_jeu.ticks_fin-struct_jeu.ticks_depart;//cette diffï¿½rence correspond au temps qu'a mis le programme ï¿½ faire une boucle (ex:16ms -> 60FPS)    if(difference<(1000/jeu_parametres.plageFPS[jeu_parametres.fps]))//si la diffï¿½rence est moins grande (le programme ï¿½ mis moins de temps que l'ï¿½quivalent des fps max alors le programme fait une pause de cette nouvelle diffï¿½rence        SDL_Delay((1000/jeu_parametres.plageFPS[jeu_parametres.fps])-difference);    else        struct_jeu.ticks_depart=struct_jeu.ticks_fin;    if(struct_jeu.ticks_fin-TICKS_RATE_EVOLUTION>=struct_jeu.ticks_evo)    {        struct_jeu.ticks_evo=struct_jeu.ticks_fin;        struct_jeu.frames_evolution++;    }}/** * \fn void relever_fps() * \brief Cette fonction relÃ¨ve dans le tableau des fps, le nombre le plus bas, le plus haut et la moyenne. Si le porgramme va "trop vite" la fonction ne sortira pas de nombre plus haut que les fps  */void relever_fps(){    int compteur=0;    struct_jeu.fpsMax=0;    struct_jeu.fpsMin=jeu_parametres.plageFPS[jeu_parametres.fps];    for(int i=0; i<20; i++)    {        if(struct_jeu.tableau_fps[i]>struct_jeu.fpsMax)struct_jeu.fpsMax=struct_jeu.tableau_fps[i];        if(struct_jeu.tableau_fps[i]<struct_jeu.fpsMin)struct_jeu.fpsMin=struct_jeu.tableau_fps[i];        struct_jeu.fpsMoy+=struct_jeu.tableau_fps[i];        compteur++;    }    struct_jeu.fpsMoy/=(compteur?compteur:1);    if(struct_jeu.fpsMax>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMax=jeu_parametres.plageFPS[jeu_parametres.fps];    if(struct_jeu.fpsMin>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMin=jeu_parametres.plageFPS[jeu_parametres.fps];    if(struct_jeu.fpsMoy>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMoy=jeu_parametres.plageFPS[jeu_parametres.fps];}void action_timer(){    if(struct_jeu.ticks_fin-TICKS_RATE_ACTIONS>=struct_jeu.ticks_actions)    {        struct_jeu.ticks_actions=struct_jeu.ticks_fin;        avancer();        sauter();        attaquer();        coupspe();        repos();        pesanteur();    }}void initialisation_fps(){    jeu_parametres.plageFPS[0]=30;    jeu_parametres.plageFPS[1]=60;    jeu_parametres.plageFPS[2]=75;    jeu_parametres.plageFPS[3]=144;    jeu_parametres.plageFPS[4]=255;    jeu_parametres.plageFPS[5]=1000;    struct_jeu.ticks_depart=0;    struct_jeu.ticks_fin=1;    struct_jeu.frames_evolution=0;    memset(struct_jeu.tableau_fps,0,sizeof(int)*20);}

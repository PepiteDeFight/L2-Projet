/** * @file        sounds.c * @brief       Contient l'impl√©mentation des fonctions en rapport avec la musique, la cr√©ation des channels, le changement de volume etc * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/sounds.h"/** * \fn void creation_canaux_musique() * \brief Cette fonction alloue des canaux de musiques pour pouvoir mettre plusieurs sons en m√™me temps comme les effets des joueurs ma √πusique d'ambiance etc . . . */void creation_canaux_musique()
{
    if(Mix_AllocateChannels(7) == -1)quitter(SDL_MIXER);    /*Cannaux:     *0:Musique fond     *1:Effets joueur 1     *2:Effets Joueur 2     *3:Effets Joueur 3     *4:Effets Joueur 4     *5:Dialogues     *6:Buffer     */    jeu_parametres.musiques[MUSIQUE_INTRO]=Mix_LoadWAV(SRC_MUSIQUE_INTRO);
    jeu_parametres.musiques[MUSIQUE_ACCUEIL]=Mix_LoadWAV(SRC_MUSIQUE_ACCUEIL);
}/** * \fn void chargement_musique(int channel, int extra,int rep) * \brief Cette fonction permet de jouer une musique * \param channel Correspond au cannal de musique (0->6) * \param extra Indice dans le tableau jeu_parametres.musiques[] correspondant √† la musique voulu * \param rep Correspond au nombre de r√©p√©titions (-1 -> infini) */void chargement_musique(int channel, int extra,int rep)
{
    Mix_PlayChannel(channel, jeu_parametres.musiques[extra], rep);
}/** * \fn void changement_volumes_musiques() * \brief Cette fonction permet de changer les volumes des canaux de musiques */void changement_volumes_musiques()
{
    if(struct_jeu.focus_loose && !jeu_parametres.arriere_plan) //si on est sorti de l'ÔøΩcran et que l'utilisateur a choisi de retirer le son    {        for(int i=0; i<7; i++)            if(Mix_Volume(i,0) == -1)quitter(SDL_MIXER);    }    else    {        if(Mix_Volume(0, jeu_parametres.musique/2) == -1)quitter(SDL_MIXER);        if(Mix_Volume(1, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(2, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(3, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(4, jeu_parametres.effets) == -1)quitter(SDL_MIXER);        if(Mix_Volume(5, jeu_parametres.dialogues) == -1)quitter(SDL_MIXER);        if(Mix_Volume(6, jeu_parametres.musique/2) == -1)quitter(SDL_MIXER);    }}/** * \fn void detruire_musique(int extra) * \brief Cette fonction permet de lib√©rer la musique stocker dans le tableau jeu_parametres.musiques[] */void detruire_musique(int extra){    Mix_FreeChunk(jeu_parametres.musiques[extra]);}/** * @file        main.c * @brief       Contient l'impl√©mentation de la fonction int main() ainsi que tous les appels de librairies dynamiques pour sdl * @author      Meunier Rodrigue * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/struct.h"/** * \fn int main(int argc, char* argv[]) * \brief La fonction main ne sert qu'a appel√© la fonction accueil et d√©marage et surtout √† appeler les libraires dynamiques SDL * * \param argc Nombre d'arguments * \param argv Contient les arguments * \return 0 si aucune erreur */int main(int argc, char* argv[]){    /*      INITIALISATION DES LIBRAIRIES DYNAMQIUES        */    errno=0;    if(SDL_Init(SDL_INIT_EVERYTHING) !=0)quitter(SDL_BASE);    if( !(IMG_Init(IMG_INIT_PNG)) )quitter(SDL_IMAGE);    if(TTF_Init() != 0)quitter(SDL_TTF);    if(!Mix_Init(MIX_INIT_MP3))quitter(SDL_MIXER);    if(Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, MIX_DEFAULT_CHANNELS, 1024) == -1)quitter(SDL_MIXER); //Initialisation de l'API Mixer    /*------------------------------------------------------*/    initialisation_parametres();    //menu_parametre();    accueil();    //SDL_Delay(5000);    quitter(QUITTER);    return 0;}#include "include/actions.h"/** * \fn void pesanteur() * \brief Cette fonction applique de la gravitÈ au joueur pour rendre le jeu plus rÈaliste * * */void pesanteur(){    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        if(!(struct_jeu.joueurs[i].positionY==RCT_Y_1 && struct_jeu.joueurs[i].positionX>=RCT_X_1 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_1 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_2 && struct_jeu.joueurs[i].positionX>=RCT_X_2 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_2 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_3 && struct_jeu.joueurs[i].positionX>=RCT_X_3 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_3 && struct_jeu.joueurs[i].etat!=JUMP) && !(struct_jeu.joueurs[i].positionY==RCT_Y_4 && struct_jeu.joueurs[i].positionX>=RCT_X_4 && struct_jeu.joueurs[i].positionX<=RCT_XMAX_4 && struct_jeu.joueurs[i].etat!=JUMP))            struct_jeu.joueurs[i].positionY++;    }}/** * \fn void avancer() * \brief La fonction avancer permet de sois faire avancer sois faire reculer les joueurs si leur Èvent respectifs sont ‡ 1 struct_jeu.tableau_event (cf struct.h) * */void avancer(){    for(int i=J1; i<J4; i++)    {        if(struct_jeu.tableau_event[i][0])        {            if(i%2)            {                struct_jeu.joueurs[i].direction=GAUCHE;                struct_jeu.joueurs[i].positionX-=2;            }            else            {                struct_jeu.joueurs[i].direction=DROITE;                struct_jeu.joueurs[i].positionX+=2;            }            struct_jeu.joueurs[i].etat=WALK;            struct_jeu.joueurs[i].modification=1;        }        if(struct_jeu.tableau_event[i][1])        {            if(i%2)            {                struct_jeu.joueurs[i].direction=DROITE;                struct_jeu.joueurs[i].positionX+=2;            }            else            {                struct_jeu.joueurs[i].direction=GAUCHE;                struct_jeu.joueurs[i].positionX-=2;            }            struct_jeu.joueurs[i].etat=WALK;            struct_jeu.joueurs[i].modification=1;        }    }}/** * \fn void sauter() * \brief Cette fonction permet de faire sauter le joueur * */void sauter(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][2])        {            struct_jeu.joueurs[i].positionY-=10;            struct_jeu.joueurs[i].etat=JUMP;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void attaquer() * \brief Cette fonction permet de faire attaquer le joueur et vÈrifie si un joueur est prÈsent pour lui infliger des dÈgats * */void attaquer(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][3])        {            struct_jeu.joueurs[i].etat=ATTACK;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void coupspe() * \brief Coupspe est comme attaquer mais c'est l'attaque spÈcial, elle est plus forte * */void coupspe(){    for(int i=J1; i<J4; i++)        if(struct_jeu.tableau_event[i][4])        {            struct_jeu.joueurs[i].etat=ATTACK;            struct_jeu.joueurs[i].modification=1;        }}/** * \fn void repos() * \brief Les personnages Ètant animÈs, si un joueur est "immobile" le personnage passe en "idle" donc se met au repos, cette fonction permet de faire ce changement * */void repos(){    for(int i=J1; i<J4; i++)        if(!struct_jeu.joueurs[i].modification)            struct_jeu.joueurs[i].etat=IDLE;}/** * @file        draw.c * @brief       Contient toutes les fonctions en rapport avec l'affichage * @author      Meunier Rodrigue * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/draw.h"SDL_Color couleurBlanc  =   {255,255,255,255};SDL_Color couleurBleu   =   {0, 0, 255, 255};SDL_Color couleurOrange =   {255, 140, 40, 255};SDL_Color couleurVert   =   {0, 255, 0, 255};SDL_Color couleurJaune  =   {255, 255, 0, 255};SDL_Color couleurRose   =   {255, 110, 137, 255};SDL_Color couleurRouge  =   {255, 0, 0, 255};SDL_Color couleurNoir   =   {0, 0, 0, 255};const int tab_rapport_X_vies[4]= {RAPPORT_X_J1_VIE,RAPPORT_X_J2_VIE,RAPPORT_X_J3_VIE,RAPPORT_X_J4_VIE};/** * \fn void definir_resolutions() * \brief Cette fonction rempli le tableau de r√©solution*/void definir_resolutions(){    jeu_parametres.reso[0][0]=1280;    jeu_parametres.reso[1][0]=800;    jeu_parametres.reso[0][1]=1440;    jeu_parametres.reso[1][1]=900;    jeu_parametres.reso[0][2]=1680;    jeu_parametres.reso[1][2]=1050;    jeu_parametres.reso[0][3]=1920;    jeu_parametres.reso[1][3]=1080;    jeu_parametres.reso[0][4]=1920;    jeu_parametres.reso[1][4]=1200;    jeu_parametres.reso[0][5]=768;    jeu_parametres.reso[1][5]=1024;    jeu_parametres.reso[0][6]=1280;    jeu_parametres.reso[1][6]=1024;    jeu_parametres.reso[0][7]=320;    jeu_parametres.reso[1][7]=480;    jeu_parametres.reso[0][8]=1366;    jeu_parametres.reso[1][8]=768;}/** * \fn void chargerTextures() * \brief Cette fonction charge en m√©moire les textures globales comme celle de l'accueil ou encore celle des param√™tres*/void chargerTextures(){    // CrÔøΩation des textures pour les parametres    SDL_Surface *surf;    char *chaine=malloc(18*sizeof(char));    strcpy(chaine,SRC_IMG_PARA);    for(int i=0; i<9; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[13]++;// cette ligne permet d'incrÔøΩmenter le numÔøΩro de l'image '1'.png        jeu_parametres.tabMenu[i]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    jeu_parametres.page=0;    free(chaine);    // CrÔøΩation de la texture de l'accueil    surf=IMG_Load(SRC_IMG_ACCUEIL);    if(surf==NULL)quitter(SDL_IMAGE);    struct_jeu.texture_accueil=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);    if(struct_jeu.texture_accueil==NULL)quitter(SDL_BASE);    SDL_FreeSurface(surf);    //CrÔøΩation textures d'arriÔøΩre plan jeu    chaine=malloc(26*sizeof(char));    strcpy(chaine,SRC_IMG_JEU);    for(int i=1; i<NB_IMG_FOND; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[21]++;// cette ligne permet d'incrÔøΩmenter le numÔøΩro de l'image '1'.png        struct_jeu.textures_fond_jeu[i-1]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    free(chaine);    //CrÔøΩation textures du plateau du jeu    chaine=malloc(29*sizeof(char));    strcpy(chaine,SRC_IMG_PLATEAU);    for(int i=1; i<NB_IMG_PLATEAU+1; i++)    {        surf=IMG_Load(chaine);        if(surf == NULL)quitter(SDL_IMAGE);        chaine[24]++;// cette ligne permet d'incrÔøΩmenter le numÔøΩro de l'image '1'.png        struct_jeu.textures_plateau_jeu[i-1]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        SDL_FreeSurface(surf);    }    free(chaine);    // CrÔøΩation de la texture du menu multijoueur    surf=IMG_Load(SRC_IMG_MULTI);    if(surf==NULL)quitter(SDL_IMAGE);    struct_jeu.texture_multijoueur=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);    if(struct_jeu.texture_multijoueur==NULL)quitter(SDL_BASE);    SDL_FreeSurface(surf);}/** * \fn void creation_textures_personnage() * \brief Cette fonction cr√©er les textures en fonction du choix du joueur sur son personnage*/void creation_textures_personnage(){    SDL_Surface *surf=NULL;    char *chaine=NULL;    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        switch(struct_jeu.joueurs[i].type_personnage/10)        {        case 0:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_CHEVALIER));            strcpy(chaine,SRC_IMG_PERSONNAGE_CHEVALIER);            chaine[30]='0'+((struct_jeu.joueurs[i].type_personnage)%10);            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[32]='0'+y;                    chaine[34]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 1:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_ELFE));            strcpy(chaine,SRC_IMG_PERSONNAGE_ELFE);            chaine[25]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[27]='0'+y;                    chaine[29]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 2:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_FEE));            strcpy(chaine,SRC_IMG_PERSONNAGE_FEE);            chaine[24]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[26]='0'+y;                    chaine[28]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        case 3:            chaine=malloc(sizeof(char)*strlen(SRC_IMG_PERSONNAGE_WARRIOR));            strcpy(chaine,SRC_IMG_PERSONNAGE_WARRIOR);            chaine[28]='0'+(struct_jeu.joueurs[i].type_personnage)%10;            for(int y=0; y<6; y++)                for(int z=0; z<10; z++)                {                    chaine[30]='0'+y;                    chaine[32]='0'+z;                    surf=IMG_Load(chaine);                    if(surf==NULL)quitter(SDL_IMAGE);                    struct_jeu.textures_personnages_joueurs[i][y][z]=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);                    SDL_FreeSurface(surf);                }            break;        }        free(chaine);    }    if(struct_jeu.nombre_joueurs)    {        if(struct_jeu.nombre_joueurs==2)        {            surf=IMG_Load(SRC_IMG_VIE2J);        }        else if(struct_jeu.nombre_joueurs==4)        {            surf=IMG_Load(SRC_IMG_VIE4J);        }        if(surf==NULL)quitter(SDL_IMAGE);        struct_jeu.vie_joueurs=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surf);        if(struct_jeu.vie_joueurs==NULL)quitter(SDL_BASE);        SDL_FreeSurface(surf);    }}/** * \fn void destruction_textures_personnage() * \brief Comme nous pouvons pas nous pemettre de stocker des Go de texture il faut lib√©rer les textures, cette fonction s'en charge*/void destruction_textures_personnage(){    for(int i=0; i<4; i++)        for(int j=0; j<6; j++)            for(int k=0; k<9; k++)                SDL_DestroyTexture(struct_jeu.textures_personnages_joueurs[i][j][k]);}/** * \fn void creation_fenetre() * \brief Cette fonction, appell√©e avant le chargement, cr√©er la fen√™tre qui accueillera les textures du jeu*/void creation_fenetre(){    SDL_Surface *icon=IMG_Load(SRC_IMG_ICON);    struct_jeu.fenetre_jeu=NULL;    struct_jeu.rendu_fenetre=NULL;    struct_jeu.fenetre_jeu=SDL_CreateWindow("Pepite De Fight",SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, jeu_parametres.reso[0][jeu_parametres.resolution], jeu_parametres.reso[1][jeu_parametres.resolution], 0);    struct_jeu.rendu_fenetre=SDL_CreateRenderer(struct_jeu.fenetre_jeu,-1,SDL_RENDERER_ACCELERATED);    if(struct_jeu.fenetre_jeu==NULL)quitter(SDL_BASE);    if(struct_jeu.rendu_fenetre==NULL)quitter(SDL_BASE);    SDL_SetWindowIcon(struct_jeu.fenetre_jeu,icon);    SDL_FreeSurface(icon);    SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_FULLSCREEN_DESKTOP);    SDL_GetWindowSize(struct_jeu.fenetre_jeu,&jeu_parametres.reso[0][9],&jeu_parametres.reso[1][9]);//rÔøΩcupÔøΩration des dims max de la fenÔøΩtre    SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_SHOWN);    struct_jeu.focus_loose=0;}/** * \fn int creation_popup_erreur(char texte[30]) * \brief Cette fonction affiche une popup en cas d'erreur avec √©crit le code d'erreur en question * \param texte[30] Code d'erreur * \return 1 si l'utilisateur souhaite poursuivre malgr√© l'erreur ou 0 si arret*/int creation_popup_erreur(char texte[30]){    SDL_Window *popup=SDL_CreateWindow("Erreur detectee !",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,400,100,SDL_WINDOW_SHOWN);    SDL_Renderer *rendu=SDL_CreateRenderer(popup,-1,SDL_RENDERER_SOFTWARE);    chargement_police(TAILLE_POLICE_T7);    SDL_Surface *text=TTF_RenderText_Solid(struct_jeu.police,texte,couleurJaune);    SDL_Surface *surface=SDL_LoadBMP(SRC_IMG_POPUP);    SDL_BlitSurface(text,NULL,surface,NULL);    SDL_Texture *texture=SDL_CreateTextureFromSurface(rendu,surface);    SDL_FreeSurface(surface);    SDL_FreeSurface(text);    SDL_RenderCopy(rendu,texture,NULL,NULL);    SDL_RenderPresent(rendu);    SDL_DestroyTexture(texture);    if(input_popup())    {        SDL_DestroyWindow(popup);        SDL_DestroyRenderer(rendu);        return 1;    }    SDL_DestroyWindow(popup);    SDL_DestroyRenderer(rendu);    return 0;}/** * \fn void chargement_demarrage() * \brief Cette fonction r√©alise l'affichage de l'√©cran de d√©marrage du jeu, en affichant le logo*/void chargement_demarrage(){    SDL_Texture *texture_fond;    SDL_Surface *surface=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0,0,0,0);//CrÔøΩation d'une surface noir permettant de contenir le texte de dÔøΩmarage du jeu    int w=1920,h=1080;    if(surface==NULL)quitter(SDL_BASE);    texture_fond=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    if(texture_fond==NULL)quitter(SDL_BASE);    if(SDL_RenderCopy(struct_jeu.rendu_fenetre, texture_fond, NULL, NULL))quitter(SDL_BASE);    SDL_RenderPresent(struct_jeu.rendu_fenetre);    //changement de taille de police    chargement_police(TAILLE_POLICE_T1);    SDL_Surface *text1=TTF_RenderText_Blended(struct_jeu.police,"PEPITE DE FIGHT",couleurBlanc);//ÔøΩcriture du text en gros "T1"    //changement de taille de police    chargement_police(TAILLE_POLICE_T4);    SDL_Surface *text2=TTF_RenderText_Blended(struct_jeu.police,"By GS'corp",couleurBlanc);//ÔøΩcriture du text en moyen "T3"    SDL_Rect rectDEST_text1= {w*0.15,h*0.33,text1->w,text1->h};    SDL_Rect rectDEST_text2= {w*0.30,h*0.48,text2->w,text2->h};    if(SDL_BlitSurface(text1,NULL,surface,&rectDEST_text1))quitter(SDL_BASE);    if(SDL_BlitSurface(text2,NULL,surface,&rectDEST_text2))quitter(SDL_BASE);    //On libÔøΩre la mÔøΩmoire de la texture et on remet la nouvelle    SDL_DestroyTexture(texture_fond);    texture_fond=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    if(texture_fond==NULL)quitter(SDL_BASE);    //=============    SDL_SetTextureBlendMode(texture_fond, SDL_BLENDMODE_BLEND);    //affichage succesif du text    SDL_Delay(3000);    for(int i=0; i<70; i++)    {        SDL_SetTextureAlphaMod(texture_fond,i);        if(SDL_RenderCopy(struct_jeu.rendu_fenetre, texture_fond, NULL, NULL))quitter(SDL_BASE);        SDL_RenderPresent(struct_jeu.rendu_fenetre);        SDL_Delay(FRAME_RATE_INTRO);    }    SDL_FreeSurface(surface);    SDL_FreeSurface(text1);    SDL_FreeSurface(text2);    SDL_DestroyTexture(texture_fond);}/** * \fn void transition_visuelle() * \brief Pour √©viter d'avoir un changement brutale de texture, cette fonction "noirci" la texture afin de r√©aliser une transition correcte*/void transition_visuelle(){    SDL_Surface *surface=SDL_GetWindowSurface(struct_jeu.fenetre_jeu);    if(surface==NULL)quitter(SDL_BASE);    SDL_DestroyTexture(struct_jeu.transition);    struct_jeu.transition=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    SDL_FreeSurface(surface);    SDL_SetTextureBlendMode(struct_jeu.transition, SDL_BLENDMODE_BLEND);    for(int i=0; i<10; i++)    {        SDL_SetTextureAlphaMod(struct_jeu.transition,(10-i)*10);        if(SDL_RenderCopy(struct_jeu.rendu_fenetre, struct_jeu.transition, NULL, NULL))quitter(SDL_BASE);        SDL_RenderPresent(struct_jeu.rendu_fenetre);        SDL_Delay(FRAME_TRANSITION);    }}/** * \fn void affichage_accueil() * \brief Cette fonction affiche le la vid√©o en arri√®re plan ainsi que le menu de l'accueil*/void affichage_accueil(){    //cette fonction affiche une image de la vidÔøΩo de fond puis l'accueil    if(struct_jeu.textures_fond_accueil[struct_jeu.frequence_video]!=NULL)    {        SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_fond_accueil[struct_jeu.frequence_video++],NULL,NULL);        struct_jeu.frequence_video++;        struct_jeu.frequence_video%=100;    }    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.texture_accueil,NULL,NULL);}/** * \fn void afficher_details_parametres() * \brief Selon la page dans les parametres que nous nous trouvons, les informations que dispose le programme doivent √™tre affich√©s, cette fonction r√©alise cette tache.*/void afficher_details_parametres(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,jeu_parametres.tabMenu[jeu_parametres.page],NULL,NULL);    SDL_Surface *text=NULL;    SDL_Surface *surfaceDest=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);    SDL_Rect Rectangle= {0,0,0,0};    SDL_Texture *texture=NULL;    //changement de taille de police    chargement_police(TAILLE_POLICE_T55);    char chaine[20];    memset(chaine,0,sizeof(char)*20);    switch(jeu_parametres.page)    {    case PAGE_GRAPHISMES:        sprintf(chaine,"%d / %d", jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution],jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]);//on convertit en chaine de caractÔøΩre la rÔøΩsolution acctuelle        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);//Appel de la fonction TTF_RenderText pour transformer la "chaine" en surface SDL        Rectangle.x=XRAPPORT_PARA_RE*1920;        Rectangle.y=YRAPPORT_PARA_RE*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient la rÔøΩsolution        SDL_FreeSurface(text);        if(jeu_parametres.mode)strcpy(chaine,"Plein Ecran");        else strcpy(chaine,"Fen√™tre");        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);        Rectangle.x=XRAPPORT_PARA_MA*1920;        Rectangle.y=YRAPPORT_PARA_MA*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient le mode d'affichage        SDL_FreeSurface(text);        sprintf(chaine,"%d", jeu_parametres.plageFPS[jeu_parametres.fps]);//on convertit en chaine de caract√®re les fps max        text=TTF_RenderText_Blended(struct_jeu.police,chaine,couleurBlanc);        Rectangle.x=XRAPPORT_PARA_FPS*1920;        Rectangle.y=YRAPPORT_PARA_FPS*1080;        Rectangle.h=text->h;        Rectangle.w=text->w;        SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient les fps        if(jeu_parametres.affichFPS)        {            SDL_FreeSurface(text);            text=IMG_Load(SRC_IMG_CHECK);            Rectangle.x=2+XRAPPORT_BOUTON_AFPS*1920;            Rectangle.y=2+YRAPPORT_BOUTON_AFPS*1080;            Rectangle.h=text->h;            Rectangle.w=text->w;            SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient l'image check pour montrer a l'utilisateur que le programme affiche les fps        }        texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surfaceDest);        if(texture==NULL)quitter(SDL_BASE);        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);        SDL_FreeSurface(text);        SDL_DestroyTexture(texture);        break;    case PAGE_INTERFACE:        break;    case PAGE_AUDIO:        //pour la musique        Rectangle.x=1+XRAPPORT_CUR_MUS*1920;        Rectangle.y=1+YRAPPORT_CUR_MUS*1080;        Rectangle.h=(YMAXRAPPORT_CUR_MUS*1080-YRAPPORT_CUR_MUS*1080);        Rectangle.w=(jeu_parametres.musique*0.01)*(int)((XMAXRAPPORT_CUR_MUS-XRAPPORT_CUR_MUS)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        //pour les effets sonores        Rectangle.x=1+XRAPPORT_CUR_EFS*1920;        Rectangle.y=1+YRAPPORT_CUR_EFS*1080;        Rectangle.h=(YMAXRAPPORT_CUR_EFS*1080-YRAPPORT_CUR_EFS*1080);        Rectangle.w=(jeu_parametres.effets*0.01)*(int)((XMAXRAPPORT_CUR_EFS-XRAPPORT_CUR_EFS)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        //pour les dialogues        Rectangle.x=1+XRAPPORT_CUR_DIA*1920;        Rectangle.y=1+YRAPPORT_CUR_DIA*1080;        Rectangle.h=(YMAXRAPPORT_CUR_DIA*1080-YRAPPORT_CUR_DIA*1080);        Rectangle.w=(jeu_parametres.dialogues*0.01)*(int)((XMAXRAPPORT_CUR_DIA-XRAPPORT_CUR_DIA)*1920);        SDL_FillRect(surfaceDest,&Rectangle,SDL_MapRGB(surfaceDest->format, 41, 238, 205));        if(jeu_parametres.arriere_plan)        {            text=IMG_Load(SRC_IMG_CHECK);            Rectangle.x=2+XRAPPORT_BOUTON_SAP*1920;            Rectangle.y=2+YRAPPORT_BOUTON_SAP*1080;            Rectangle.h=text->h;            Rectangle.w=text->w;            SDL_BlitSurface(text,NULL,surfaceDest,&Rectangle);//on blit la surface text qui contient l'image check pour montrer ÔøΩ l'utilisateur que le programme affiche les fps            SDL_FreeSurface(text);        }        texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surfaceDest);        if(texture==NULL)quitter(SDL_BASE);        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);        SDL_DestroyTexture(texture);        break;    case PAGE_CONTROLES:        break;    }    SDL_FreeSurface(surfaceDest);}/** * \fn void affichage_fps() * \brief Comme dans tous jeu de "baston" on peut √™tre ammen√© √† quel fr√©quence le programme "tourne", cette fonction affiche les fps moyen, min et max si le joueur √† choisi de les afficher*/void affichage_fps(){    if(jeu_parametres.affichFPS)    {        char chaine[20];        sprintf(chaine,"FPS:%d, max:%d min:%d",struct_jeu.fpsMoy,struct_jeu.fpsMax,struct_jeu.fpsMin);        //changement de taille de police        chargement_police(TAILLE_POLICE_T8);        SDL_Surface *text=TTF_RenderText_Solid(struct_jeu.police,chaine,couleurBlanc);        SDL_Texture *texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,text);        SDL_Rect position= {0,0,text->w,text->h};        SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,&position);        SDL_FreeSurface(text);        SDL_DestroyTexture(texture);    }}/** * \fn void rendre_affichage() * \brief Pour √©viter de se m√©langer les pinceaux, cette fonction r√©alise l'affichage du rendu, comme en SDL les textures sont superpos√©es comme des calques, cette fonction affichera le sommet du calque */void rendre_affichage(){    SDL_RenderPresent(struct_jeu.rendu_fenetre);}/** * \fn void afficher_partie() * \brief Cette fonction affiche le fond d'√©cran de la partie ainsi que les plateformes, celles ci sont s√©lectionn√©es dans les param√™tres */void afficher_partie(){    /*Pour l'instant la fonction fait juste render_copy mais ÔøΩ l'avenir cette fonction calculera la surface de la texture ÔøΩ afficher     *     */    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_fond_jeu[struct_jeu.texture_fond_jeu_selectione],NULL,NULL);    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_plateau_jeu[struct_jeu.texture_plateau_jeu_selectione],NULL,NULL);}/** * \fn void afficher_joueurs() * \brief En fonction des textures s√©l√©ctionn√©es par le joueur, le programme durant la partie va afficher les joueurs gr√¢ce √† cette fonction */void afficher_joueurs(){    SDL_Rect position_Final= {0,0,(int)(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_LARGEUR_PERSO),(int)(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_HAUTEUR_PERSO)};    SDL_RendererFlip flip = SDL_FLIP_VERTICAL;    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        position_Final.x=((struct_jeu.joueurs[i].positionX)*(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution])/1920)-jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_OFFSET_X;        position_Final.y=((struct_jeu.joueurs[i].positionY)*(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution])/1080)-jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_OFFSET_Y;        position_Final.h=(int)(jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_Y_PERSO);        position_Final.w=(int)(jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*RAPPORT_X_PERSO);        if(struct_jeu.joueurs[i].direction==DROITE)        {            if(SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.textures_personnages_joueurs[i][struct_jeu.joueurs[i].etat][struct_jeu.frames_evolution%10],NULL,&position_Final) <0)quitter(SDL_BASE);        }        else        {            if(SDL_RenderCopyEx(struct_jeu.rendu_fenetre,struct_jeu.textures_personnages_joueurs[i][struct_jeu.joueurs[i].etat][struct_jeu.frames_evolution%10],NULL,&position_Final,180,NULL,flip) <0)quitter(SDL_BASE);        }    }}/** * \fn void afficher_vie_joueurs() * \brief Les personnages ont une bare de vie, donc √† tout moment le joueur est ammen√© √† savoir combien de vie a son personnage, cette fonction affiche √† l'√©cran la vie de tous les joueurs*/void afficher_vie_joueurs(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.vie_joueurs,NULL,NULL);    SDL_Surface *surface=SDL_CreateRGBSurface(0, 1920, 1080, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000);    SDL_Texture *texture=NULL;    SDL_Rect Rectangle= {0,RAPPORT_Y_VIE*1080,0,RAPPORT_H_VIE*1080};    for(int i=0; i<struct_jeu.nombre_joueurs; i++)    {        Rectangle.x=tab_rapport_X_vies[i]*1920;        Rectangle.w=((RAPPORT_H_VIE-Rectangle.x)*1920)*(struct_jeu.joueurs[i].vie/100);        switch(i)        {        case J1:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 255, 0, 0));            break;        case J2:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 255, 255, 0));            break;        case J3:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 0, 0, 255));            break;        case J4:            SDL_FillRect(surface,&Rectangle,SDL_MapRGB(surface->format, 0, 255, 0));            break;        }    }    texture=SDL_CreateTextureFromSurface(struct_jeu.rendu_fenetre,surface);    SDL_RenderCopy(struct_jeu.rendu_fenetre,texture,NULL,NULL);    SDL_FreeSurface(surface);    SDL_DestroyTexture(texture);}/** * \fn void afficher_ecran_multijoueur() * \brief Une fois le mode multijoueur s√©l√©ctionn√©, le joueur est ammen√© √† selectionner un mode "2j/4J :: local / r√©seau", cette fonction affiche √† l'√©cran des cases o√π cliquer pour selectionner ce mode */void afficher_ecran_multijoueur(){    SDL_RenderCopy(struct_jeu.rendu_fenetre,struct_jeu.texture_multijoueur,NULL,NULL);}/** * \fn void afficher_pause() * \brief Si le(s) joueur(s) est(sont) en local, il y a la possibilit√© de mettre pause, cette fonction affiche le menu pause */void afficher_pause(){}/** * \fn void modifier_window() * \brief Lorsque l'utilisateur est dans les param√®tres du jeu, il peut √™tre ammen√© √† modifier la taille de sa fen√™tre, cette fonction regroupe toutes les fonctions r√©alisant ce changement */void modifier_window(){    if(jeu_parametres.mode)    {        SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_FULLSCREEN_DESKTOP);        SDL_GetWindowSize(struct_jeu.fenetre_jeu,&jeu_parametres.reso[0][9],&jeu_parametres.reso[1][9]);    }    else    {        SDL_SetWindowFullscreen(struct_jeu.fenetre_jeu,SDL_WINDOW_SHOWN);        SDL_SetWindowSize(struct_jeu.fenetre_jeu,jeu_parametres.reso[0][jeu_parametres.resolution], jeu_parametres.reso[1][jeu_parametres.resolution]);        SDL_SetWindowPosition(struct_jeu.fenetre_jeu,SDL_WINDOWPOS_CENTERED,SDL_WINDOWPOS_CENTERED);    }}/** * @file        input.c * @brief       Contient l'impl√©mentation des fonctions d'√©v√©nements ainsi que de jeu * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/input.h"/** * \fn int input_popup() * \brief Cette fonction g√®re l'entr√©e des √©v√©nements de la popup d'erreur, dans le cas o√π une erreur survient (cf : quitter() -> init.c) * * \return RETOUR_QUITTER si l'utilisateur veut mettre fin au programme ou RETOUR_POURSUIVRE s'il souhaite poursuivre malgr√© l'erreur */int input_popup(){    SDL_Event event;    while(1)    {        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=XPOURSUIVRE_MIN && event.button.x<=XPOURSUIVRE_MAX && event.button.y>=YPOURSUIVRE_MIN && event.button.y<=YPOURSUIVRE_MAX)                    return RETOUR_POURSUIVRE;                if(event.button.x>=XQUITTER_MIN && event.button.x<=XQUITTER_MAX && event.button.y>=YQUITTER_MIN && event.button.y<=YQUITTER_MAX)                    return RETOUR_QUITTER;                break;//pour faire joli            case SDL_QUIT:                return RETOUR_QUITTER;                break;//pour faire joli            }        delay();    }    return RETOUR_QUITTER;}/** * \fn void accueil() * \brief Cette fonction g√®re l'entr√©e des √©v√©nements de l'accueil, c'est la fonction principale du programme, elle permet √† l'utilisateur d'acc√©der au diff√©rents modes de jeu ainsi qu'aux param√®tres et de quitter * */void accueil(){    //on clear le visuel    transition_visuelle();    //on met la musique    chargement_musique(0,MUSIQUE_ACCUEIL,INFINI);    SDL_Event event;    SDL_bool continuer=SDL_TRUE;    while(continuer)    {        affichage_accueil();        affichage_fps();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                quitter(QUITTER);                break;            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTONS_ACCUEIL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTONS_ACCUEIL) //si on se situe dans l'interval graphique des boutons                {                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CAMPAGNE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CAMPAGNE) //Appuis du bouton Campagne par l'utilisateur                    {                        campagne();                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_MULTIJOUEUR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_MULTIJOUEUR) //Appuis du bouton Campagne par l'utilisateur                    {                        struct_jeu.nombre_joueurs=multijoueur();                        if(struct_jeu.reseauOn)choix_serveur();                        if(struct_jeu.nombre_joueurs)choix_personnage();                        if(struct_jeu.nombre_joueurs)partie();                        struct_jeu.nombre_joueurs=0;                        struct_jeu.reseauOn=0;                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_PARAMETRES && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_PARAMETRES) //Appuis du bouton Campagne par l'utilisateur                    {                        menu_parametre();                    }                    if(event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_QUITTER && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_QUITTER) //Appuis du bouton Quitter par l'utilisateur                    {                        quitter(QUITTER);                    }                }                break;            case SDL_WINDOWEVENT:                if(!jeu_parametres.arriere_plan)                {                    switch(event.window.event)                    {                    case SDL_WINDOWEVENT_MINIMIZED:                        struct_jeu.focus_loose=1;                        break;                    case SDL_WINDOWEVENT_MAXIMIZED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_GAINED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_LOST:                        struct_jeu.focus_loose=1;                        break;                    }                    changement_volumes_musiques();                }                break;            }        delay();    }}/** * \fn void menu_parametre() * \brief Cette fonction g√®re l'entr√©e des √©v√©nements du menu des parametre, cette fonction permet √† l'utilisateur gr√¢ce √† l'interface graphique de changer ses controles, ses fps etc... * */void menu_parametre(){    int buffer;    SDL_Event event;    while(1)    {        afficher_details_parametres();        affichage_fps();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                sauvegarde_parametres();                quitter(QUITTER);                break;            case SDL_MOUSEBUTTONDOWN:                if(event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]/RAPPORT_PARAMETRE_CHOIX) //Selection du menu en question (parametre / audio / . . .                {                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_GRAPHISMES && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_GRAPHISMES)                        jeu_parametres.page=0;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_JOUABILITE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_JOUABILITE)                        jeu_parametres.page=1;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_INTERFACE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_INTERFACE)                        jeu_parametres.page=2;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_SOURISCLAVIER && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_SOURISCLAVIER)                        jeu_parametres.page=3;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_MANETTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_MANETTE)                        jeu_parametres.page=4;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_AUDIO && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_AUDIO)                        jeu_parametres.page=5;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_CONTROLES && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_CONTROLES)                        jeu_parametres.page=6;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_CONTROLESMANETTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_CONTROLESMANETTE)                        jeu_parametres.page=7;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XRAPPORT_COMPTE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]/XMAXRAPPORT_COMPTE)                        jeu_parametres.page=8;                }                switch(jeu_parametres.page)                {                case PAGE_GRAPHISMES:                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_MA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_MA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_MA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_MA)                    {                        jeu_parametres.mode=0;                        modifier_window();                    }//si on appuis sur le bouton (-) pour le mode d'affichage                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BP_MA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BP_MA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BP_MA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BP_MA)                    {                        jeu_parametres.mode=1;                        modifier_window();                    }//si on appuis sur le bouton (+) pour le mode d'affichage                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_RE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_RE && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_RE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_RE && !jeu_parametres.mode)                    {                        if(jeu_parametres.resolution>0)                        {                            jeu_parametres.resolution--;                            modifier_window();                        }                    }//si on appuis sur le bouton (-) pour la rÔøΩsolution                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.resolution]*XRAPPORT_BP_RE && event.button.x<=jeu_parametres.reso[0][jeu_parametres.resolution]*XMAXRAPPORT_BP_RE && event.button.y>=jeu_parametres.reso[1][jeu_parametres.resolution]*YRAPPORT_BP_RE && event.button.y<=jeu_parametres.reso[1][jeu_parametres.resolution]*YMAXRAPPORT_BP_RE && !jeu_parametres.mode)                    {                        if(jeu_parametres.resolution<8)                        {                            jeu_parametres.resolution++;                            modifier_window();                        }                    }//si on appuis sur le bouton (+) pour la rÔøΩsolution                    if(jeu_parametres.mode)                    {                        if(event.button.x>=jeu_parametres.reso[0][9]*XRAPPORT_BM_MA && event.button.x<=jeu_parametres.reso[0][9]*XMAXRAPPORT_BM_MA && event.button.y>=jeu_parametres.reso[1][9]*YRAPPORT_BM_MA && event.button.y<=jeu_parametres.reso[1][9]*YMAXRAPPORT_BM_MA)                        {                            if(jeu_parametres.mode>0)                            {                                jeu_parametres.mode--;                                modifier_window();                            }                        }//si on appuis sur le bouton (-) pour le mode d'affichage et qu'on est en mode plein ÔøΩcran                    }                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BM_FPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BM_FPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BM_FPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BM_FPS)                    {                        if(jeu_parametres.fps>0)                        {                            jeu_parametres.fps--;                            modifier_window();                        }                    }//si on appuis sur le bouton (-) pour les FPS                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BP_FPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BP_FPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BP_FPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BP_FPS)                    {                        if(jeu_parametres.fps<5)                        {                            jeu_parametres.fps++;                            modifier_window();                        }                    }//si on appuis sur le bouton (+) pour les FPS;                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_AFPS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_AFPS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_AFPS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_AFPS)                    {                        if(jeu_parametres.affichFPS)jeu_parametres.affichFPS=0;                        else jeu_parametres.affichFPS=1;                    }//si on appuis sur le bouton pour afficher les FPS;                    break;                case PAGE_INTERFACE:                    break;                case PAGE_AUDIO:                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_MUS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_MUS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_MUS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_MUS)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_MUS*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_MUS-XRAPPORT_CUR_MUS)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.musique=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur de la musique                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_EFS && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_EFS && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_EFS && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_EFS)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_EFS*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_EFS-XRAPPORT_CUR_EFS)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.effets=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur des effets sonores                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_CUR_DIA && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_CUR_DIA && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_CUR_DIA && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_CUR_DIA)                    {                        while(event.type != SDL_MOUSEBUTTONUP)                        {                            SDL_PollEvent(&event);                            buffer=100*((int)(event.button.x-XRAPPORT_CUR_DIA*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]))/((int)((XMAXRAPPORT_CUR_DIA-XRAPPORT_CUR_DIA)*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]));                            if(buffer <=100 && buffer >=0)jeu_parametres.dialogues=buffer;                            afficher_details_parametres();                            affichage_fps();                            rendre_affichage();                        }                    }//si on appuis sur le curseur des effets sonores                    if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_SAP && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_SAP && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_SAP && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_SAP && jeu_parametres.dialogues<100)                    {                        if(jeu_parametres.arriere_plan)jeu_parametres.arriere_plan=0;                        else jeu_parametres.arriere_plan=1;                    }//si on appuis sur le bouton pour activer les sons en arriÔøΩre plan                    changement_volumes_musiques();                    break;                case PAGE_CONTROLES:                    break;                }                if(event.button.y>=YRAPPORT_BOUTON_VALID*jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_VALID)                {                    if(event.button.x>=XRAPPORT_BOUTON_RESET*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_RESET)                    {                        remove(SRC_FICHIER_PARA);                        chargement_parametres();                        modifier_window();                        changement_volumes_musiques();                    }                    if(event.button.x>=XRAPPORT_BOUTON_BACK*jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution] && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_BACK)                    {                        changement_volumes_musiques();                        sauvegarde_parametres();                        return;                    }                }//boutons de validation appuis ÔøΩ la souris                break;            case SDL_KEYDOWN:                switch(event.key.keysym.sym)                {                case SDLK_r:                    remove(SRC_FICHIER_PARA);                    chargement_parametres();                    changement_volumes_musiques();                    sauvegarde_parametres();                    break;                case SDLK_ESCAPE:                    changement_volumes_musiques();                    sauvegarde_parametres();                    return;                }                break;            case SDL_WINDOWEVENT:                if(!jeu_parametres.arriere_plan)                {                    switch(event.window.event)                    {                    case SDL_WINDOWEVENT_MINIMIZED:                        struct_jeu.focus_loose=1;                        break;                    case SDL_WINDOWEVENT_MAXIMIZED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_GAINED:                        struct_jeu.focus_loose=0;                        break;                    case SDL_WINDOWEVENT_FOCUS_LOST:                        struct_jeu.focus_loose=1;                        break;                    }                    changement_volumes_musiques();                }                break;            }        delay();    }}/** * \fn void campagne() * \brief Cette fonction g√®re les √©v√©nements de du menu campagne pour une √©ventuelle partie en solo * */void campagne(){}/** * \fn int multijoueur() * \brief Contrairement √† campagne la fonction multijoueur permet de r√©cup√©rer la fa√ßon dont une partie va se d√©roul√©, elle permet √©galement de savoir si une partie va se d√©rouler en r√©seau ou non * * \return nombre_joueurs (2/4) ou 0 si abandon */int multijoueur(){    transition_visuelle();    afficher_ecran_multijoueur();    rendre_affichage();    SDL_Event event;    while(1)    {        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_KEYDOWN:                if(event.key.keysym.sym == SDLK_ESCAPE)                    return 0;            case SDL_QUIT:                quitter(QUITTER);            case SDL_MOUSEBUTTONDOWN:                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_2JL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_2JL && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_2JL && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_2JL)                {                    struct_jeu.reseauOn=0;                    return 2;                }//si on appuis sur le bouton 2 J local                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_4JL && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_4JL && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_4JL && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_4JL)                {                    struct_jeu.reseauOn=0;                    return 4;                }//si on appuis sur le bouton 4 J local                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_2JR && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_2JR && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_2JR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_2JR)                {                    struct_jeu.reseauOn=1;                    return 2;                }//si on appuis sur le bouton 2 J reseau                if(event.button.x>=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XRAPPORT_BOUTON_4JR && event.button.x<=jeu_parametres.reso[0][jeu_parametres.mode?9:jeu_parametres.resolution]*XMAXRAPPORT_BOUTON_4JR && event.button.y>=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YRAPPORT_BOUTON_4JR && event.button.y<=jeu_parametres.reso[1][jeu_parametres.mode?9:jeu_parametres.resolution]*YMAXRAPPORT_BOUTON_4JR)                {                    struct_jeu.reseauOn=1;                    return 4;                }//si on appuis sur le bouton 4 J reseau                break;            }    }    return 0;}/** * \fn void partie() * \brief La fonction coeur du jeu, elle permet de faire une partie du jeu en multijoueur, cette fonction r√©cup√®res les actions des joueurs et appels les fonctions d'actions.c pour mouvoir, faire attacker les joueurs * * */void partie(){    transition_visuelle();    SDL_Event event;    for(;;)    {        afficher_partie();        afficher_joueurs();        rendre_affichage();        while(SDL_PollEvent(&event))            switch(event.type)            {            case SDL_QUIT:                quitter(QUITTER);                break;            case SDL_KEYDOWN:                if(event.key.keysym.sym == jeu_parametres.avancer1)struct_jeu.tableau_event[J1][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer2)struct_jeu.tableau_event[J2][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer3)struct_jeu.tableau_event[J3][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.avancer4)struct_jeu.tableau_event[J4][0]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer1)struct_jeu.tableau_event[J1][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer2)struct_jeu.tableau_event[J2][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer3)struct_jeu.tableau_event[J3][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.reculer4)struct_jeu.tableau_event[J4][1]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter1)struct_jeu.tableau_event[J1][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter2)struct_jeu.tableau_event[J2][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter3)struct_jeu.tableau_event[J3][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.sauter4)struct_jeu.tableau_event[J4][2]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer1)struct_jeu.tableau_event[J1][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer2)struct_jeu.tableau_event[J2][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer3)struct_jeu.tableau_event[J3][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.attaquer4)struct_jeu.tableau_event[J4][3]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe1)struct_jeu.tableau_event[J1][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe2)struct_jeu.tableau_event[J2][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe3)struct_jeu.tableau_event[J3][4]=TRUE;                if(event.key.keysym.sym == jeu_parametres.coupspe4)struct_jeu.tableau_event[J4][4]=TRUE;                if(event.key.keysym.sym == SDLK_ESCAPE)pause();                break;            case SDL_KEYUP:                if(event.key.keysym.sym == jeu_parametres.avancer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.avancer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][0]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.reculer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][1]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.sauter4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][2]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.attaquer4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][3]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe1)                {                    struct_jeu.joueurs[J1].modification=0;                    struct_jeu.tableau_event[J1][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe2)                {                    struct_jeu.joueurs[J2].modification=0;                    struct_jeu.tableau_event[J2][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe3)                {                    struct_jeu.joueurs[J3].modification=0;                    struct_jeu.tableau_event[J3][4]=FALSE;                }                if(event.key.keysym.sym == jeu_parametres.coupspe4)                {                    struct_jeu.joueurs[J4].modification=0;                    struct_jeu.tableau_event[J4][4]=FALSE;                }                break;            }        action_timer();        affichage_fps();        delay();    }}/** * \fn void choix_serveur() * \brief Cette fonction permet de r√©cup√®rer l'ip du serveur sur lequel une √©ventuelle partie en r√©seau se d√©roulerais * * */void choix_serveur(){}/** * \fn void choix_personnage() * \brief Cette fonction permet de savoir quel personnage chaque joueur va jouer * * */void choix_personnage(){    transition_visuelle();    struct_jeu.joueurs[0].type_personnage=01;    struct_jeu.joueurs[1].type_personnage=02;    for(int i=0; i<4; i++) //on remplit les structures des joueurs avec les valeurs adÔøΩquats restantes    {        struct_jeu.joueurs[i].vie=INIT_VIE;        struct_jeu.joueurs[i].evolution=0;        struct_jeu.joueurs[i].etat=IDLE;        struct_jeu.joueurs[i].direction=(i%2?GAUCHE:DROITE);//le(s) joueur(s) 1( et 3) est(sont) contre(s) le(s) joueur(s) 2(et 4)        struct_jeu.joueurs[i].positionY=1030;    }    struct_jeu.joueurs[0].positionX=410;//JOUEUR 1    struct_jeu.joueurs[1].positionX=1560;//JOUEUR 2    struct_jeu.joueurs[2].positionX=530;//JOUEUR 3    struct_jeu.joueurs[3].positionX=1440;//JOUEUR 4    creation_textures_personnage();}/** * \fn void choix_personnage() * \brief Cette fonction permet de faire une pause tant que l'utilisateur n'a pas appuyer sur echape, elle n'est pas dans timer.c car elle n'agit pas directement sur le temps, elle fait une sorte de boucle sans changer l'affichage. Ps: disponible uniquement en local */void pause(){    if(!struct_jeu.reseauOn)    {        afficher_pause();        SDL_Event event;        while(1)        {            while(SDL_PollEvent(&event))                switch(event.type)                {                case SDL_QUIT:                    quitter(QUITTER);                    break;                case SDL_KEYDOWN:                    if(event.key.keysym.sym == SDLK_ESCAPE)return;                }            delay();        }    }}/** * @file        sockets.c * @brief       Contient l'impl√©mentation des fonctions de r√©seau pour jouer en multijoueur * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/sockets.h"/** * \fn void initialisation_socket() * \brief Cette fonction permet d'initialiser les param√®tres de la socket */void initialisation_socket(){    memset(&(sockets.adresse_serveur),0,sizeof(sockets.adresse_serveur));    sockets.adresse_serveur.sin_port = htons(30000);    sockets.adresse_serveur.sin_family = AF_INET;    sockets.adresse_serveur.sin_addr.s_addr = htonl(INADDR_ANY);}/** * \fn int hostname_to_ip(char * hostname , char* ip) * \brief Cette fonction transforme un hostname en ip "claire" pour le programme * return 0 si aucune erreur */int hostname_to_ip(char * hostname , char* ip){    struct hostent *he;    struct in_addr **addr_list;    int i;    if ( (he = gethostbyname( hostname ) ) == NULL)quitter(RESEAU);    addr_list = (struct in_addr **) he->h_addr_list;    for(i = 0; addr_list[i] != NULL; i++)    {        //Return the first one;        strcpy(ip , inet_ntoa(*addr_list[i]) );        return 0;    }    return 1;}/** * \fn void creation_socket(char *hostname) * \brief Cette fonction permet de cr√©er la socket qui √©couteras sur le r√©seau les packets de donn√©es */void creation_socket(char *hostname){    memset(sockets.buffer,0,sizeof(char)*SIZE_BUFFER);    char ip[100];    hostname_to_ip(hostname, ip);    if ((sockets.socket_serveur =socket(AF_INET,SOCK_STREAM,0))== -1)        quitter(RESEAU);    /* bind serveur - socket */    bind(sockets.socket_serveur,(struct sockaddr *)&sockets.adresse_serveur,sizeof(sockets.adresse_serveur));    /* ecoute sur la socket */    listen(sockets.socket_serveur,5);    sockets.mon_address_longueur = sizeof(sockets.adresse_serveur);}/** * \fn void connexion_client() * \brief Cette fonction bloquante, permet d'attendre qu'un client (autre pc) se connect au serveur(ce pc) */void connexion_client(){    /* on attend que le client se connecte */    sockets.socket_client = accept(sockets.socket_serveur,(struct sockaddr *)&(sockets.socket_client),&(sockets.mon_address_longueur));}/** * \fn void lire_socket() * \brief Cette fonction traite les donn√©es pr√©sentes sur la socket */void lire_socket(){    memset(sockets.buffer,0,sizeof(char)*SIZE_BUFFER);    recv(sockets.socket_client, sockets.buffer, sizeof(sockets.buffer),0);    if(sockets.buffer[0]=='$')    {        int i=1;        for(int y=0; y<5; y++)        {            struct_jeu.tableau_event[J2][y]=sockets.buffer[i++];        }        for(int y=0; y<5; y++)        {            struct_jeu.tableau_event[J4][y]=sockets.buffer[i++];        }    }}/** * \fn void ecrire_socket() * \brief Cette fonction permet d'envoyer des donn√©es sur la socket */void ecrire_socket() //struct_jeu.tableau_event[J2/J4][0->4]{    sockets.buffer[0]='$';    int i=1;    for(int y=0; y<5; y++)    {        sockets.buffer[i++]=struct_jeu.tableau_event[J2][y];    }    for(int y=0; y<5; y++)    {        sockets.buffer[i++]=struct_jeu.tableau_event[J4][y];    }    send(sockets.socket_serveur,sockets.buffer,sizeof(sockets.buffer),0);}/** * \fn void destruction_socket() * \brief Cette fonction met fin √† la socket, elle lib√®re l'espace */void destruction_socket(){    shutdown(sockets.socket_serveur,2);    close(sockets.socket_serveur);}/** * @file        actions.h * @brief       Contient les d√©clarations des fonctions d'actions des joueurs * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __ACTIONS__#define __ACTIONS__#include "struct.h"void pesanteur();void avancer();void sauter();void attaquer();void coupspe();void repos();#endif // __ACTIONS__/** * @file        draw.h * @brief       Contient les d√©clarations des fonctions d'affichage * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __DRAW__#define __DRAW__#include "struct.h"/*  FONCTIONS   */void definir_resolutions();void chargerTextures();void creation_textures_personnage();void destruction_textures_personnage();void creation_fenetre();int creation_popup_erreur(char texte[30]);void chargement_demarrage();void transition_visuelle();void affichage_accueil();void afficher_details_parametres();void affichage_fps();void rendre_affichage();void afficher_partie();void afficher_joueurs();void afficher_vie_joueurs();void afficher_ecran_multijoueur();void afficher_pause();void modifier_window();#endif // __DRAW__/** * @file        input.h * @brief       Contient les d√©clarations des fonctions d'√©v√©nements * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __INPUT__#define __INPUT__#include "struct.h"int input_popup();void accueil();void menu_parametre();void campagne();int multijoueur();void partie();void choix_serveur();void choix_personnage();void pause();#endif // __INPUT__/** * @file        sockets.h * @brief       Contient les d√©clarations des fonctions li√©es au r√©seau * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __SOCKETS__#define __SOCKETS__#include "struct.h"/*  FONCTIONS   */void initialisation_socket();int hostname_to_ip(char * hostname , char* ip);void creation_socket(char *hostname);void connexion_client();void lire_socket();void ecrire_socket();void destruction_socket();#endif // __SOCKETS__/** * @file        init.c * @brief       Contient l'impl√©mentation des fonctions d'initialisation, comme la police, les variables, les structures . . . * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/init.h"/** * \fn void initialisation_parametres() * \brief Cette fonction permet d'initialiser la plupart des structures et d'appeler les fonctions pour cr√©er la fenetre, lancer l'√©cran de chargement et r√©cup√©rer les parametres utilisateur comme les contr√¥les */void initialisation_parametres(){    //RÔøΩcupÔøΩrations des parametres (controls,...)    chargement_parametres();    initialisation_fps();    struct_jeu.ticks_depart=SDL_GetTicks();    struct_jeu.ticks_evo=struct_jeu.ticks_depart;    struct_jeu.ticks_actions=struct_jeu.ticks_depart;    //DÔøΩmarrage des fonctions nÔøΩcÔøΩssaires ÔøΩ l'affichage    definir_resolutions();    creation_fenetre();    modifier_window();    //chargement des textures    chargerTextures();    struct_jeu.frequence_video=0;//on initialise la variable qui gÔøΩre les textures de fond de vidÔøΩo d'accueil    struct_jeu.texture_fond_jeu_selectione=2;    struct_jeu.texture_plateau_jeu_selectione=0;    //Chargement de la police    chargement_police(TAILLE_POLICE_T1);    //Chargement de la musique d'intro    creation_canaux_musique();    chargement_musique(6,MUSIQUE_INTRO,0);    changement_volumes_musiques();    //affichage de l'ÔøΩcran de chargement (dÔøΩmarrage)    chargement_demarrage();    detruire_musique(MUSIQUE_INTRO);}/** * \fn void chargement_police(int taille) * \brief Cette fonction permet de chnager la taille de la police (cf defs.h -> diff√©rentes tailles de police) * \param taille Correspond √† la taille choisie */void chargement_police(int taille){    TTF_CloseFont(struct_jeu.police);    struct_jeu.police=NULL;    struct_jeu.police=TTF_OpenFont(POLICE,taille);    if(struct_jeu.police==NULL)quitter(SDL_TTF);}/** * \fn void chargement_parametres() * \brief Cette fonction permet de sois cr√©√©er le fichier de sauvegarde des parametres sois de r√©cup√©rer les parametres sauvegard√©s */void chargement_parametres() //Cette fonction ÔøΩ pour but de rÔøΩcupÔøΩrer les contrÔøΩles sauvegardÔøΩs; Si jamais des contrÔøΩles sont perdu ou inÔøΩxistants, la fonction remet/met par dÔøΩfault des contrÔøΩles{    FILE *f_parametres=NULL;    f_parametres=fopen(SRC_FICHIER_PARA,"r");    if(errno==2) //si fichier introuvable alors crÔøΩation du fichier    {        fclose(f_parametres);        f_parametres=fopen(SRC_FICHIER_PARA,"w");        fprintf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : %d\nAttaquer : %d\nCoupSpe : %d\n", DEF_MODE, DEF_RESO, DEF_FPS, DEF_AFFPS, DEF_ECHELLE, DEF_SOUND,DEF_SOUND, DEF_SOUND, 1, DEF_AVANCER1, DEF_RECULER1, DEF_SAUTER1, DEF_ATTAQUE1, DEF_ATTAQUESPE1, DEF_AVANCER2, DEF_RECULER2, DEF_SAUTER2, DEF_ATTAQUE2, DEF_ATTAQUESPE2, DEF_AVANCER3, DEF_RECULER3, DEF_SAUTER3, DEF_ATTAQUE3, DEF_ATTAQUESPE3, DEF_ATTAQUE4, DEF_RECULER4, DEF_SAUTER4, DEF_ATTAQUE4, DEF_ATTAQUESPE4);        fclose(f_parametres);        f_parametres=fopen(SRC_FICHIER_PARA,"r");    }    fscanf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : %d\nAttaquer : %d\nCoupSpe : %d\n", &jeu_parametres.mode, &jeu_parametres.resolution, &jeu_parametres.fps, &jeu_parametres.affichFPS, &jeu_parametres.echelle, &jeu_parametres.musique, &jeu_parametres.effets, &jeu_parametres.dialogues, &jeu_parametres.arriere_plan, &jeu_parametres.avancer1, &jeu_parametres.reculer1, &jeu_parametres.sauter1, &jeu_parametres.attaquer1, &jeu_parametres.coupspe1, &jeu_parametres.avancer2, &jeu_parametres.reculer2, &jeu_parametres.sauter2, &jeu_parametres.attaquer2, &jeu_parametres.coupspe2, &jeu_parametres.avancer3, &jeu_parametres.reculer3, &jeu_parametres.sauter3, &jeu_parametres.attaquer3, &jeu_parametres.coupspe3, &jeu_parametres.avancer4, &jeu_parametres.reculer4, &jeu_parametres.sauter4, &jeu_parametres.attaquer4, &jeu_parametres.coupspe4);    fclose(f_parametres);}/** * \fn void sauvegarde_parametres() * \brief Cette fonction permet de sauvegarder les parametres utilisateur dans le fichier de sauvegarde */void sauvegarde_parametres(){    FILE *f_parametres=NULL;    f_parametres=fopen(SRC_FICHIER_PARA,"w");    fprintf(f_parametres,"-GRAPHISMES-\nMode : %d\nResolution : %d\nFps : %d\nAfficherFps : %d\n-INTERFACE-\nEchelle : %d\n-AUDIO-\nMusique : %d\nEffets : %d\nDialogues : %d\nArrierePlan : %d\n-C-O-N-T-R-O-L-E-S-\n_JOUEUR1_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR2_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR3_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n_JOUEUR4_\nAvancer : %d\nReculer : %d\nSauter : : %d\nAttaquer : %d\nCoupSpe : %d\n", jeu_parametres.mode, jeu_parametres.resolution, jeu_parametres.fps, jeu_parametres.affichFPS, jeu_parametres.echelle, jeu_parametres.musique, jeu_parametres.effets, jeu_parametres.dialogues, jeu_parametres.arriere_plan, jeu_parametres.avancer1, jeu_parametres.reculer1, jeu_parametres.sauter1, jeu_parametres.attaquer1, jeu_parametres.coupspe1, jeu_parametres.avancer2, jeu_parametres.reculer2, jeu_parametres.sauter2, jeu_parametres.attaquer2, jeu_parametres.coupspe2, jeu_parametres.avancer3, jeu_parametres.reculer3, jeu_parametres.sauter3, jeu_parametres.attaquer3, jeu_parametres.coupspe3, jeu_parametres.avancer4, jeu_parametres.reculer4, jeu_parametres.sauter4, jeu_parametres.attaquer4, jeu_parametres.coupspe4);    fclose(f_parametres);}/** * \fn void quitter(int code) * \brief Cette fonction permet de terminer le programme en faisant apparaitre une popup permettant √† l'utilisateur de sois mettre fin au programme sois poursuivre malgr√© l'erreur * \param code Corrrespond au code d'erreur d'appel de la fonction (cf defs.h -> code d'erreurs) */void quitter(int code){    char erreur[30];    switch(code)    {    case QUITTER    :        strcpy(erreur,"Programme Quit");        break;    case FOPEN_ERR  :        strcpy(erreur,strerror(errno));        break;    case SDL_IMAGE  :        strcpy(erreur,IMG_GetError());        break;    case SDL_BASE   :        strcpy(erreur,SDL_GetError());        break;    case SDL_TTF    :        strcpy(erreur,TTF_GetError());        break;    case SDL_MIXER  :        strcpy(erreur,Mix_GetError());        break;    case RESEAU     :        strcpy(erreur,"R√©seau/socket");        break;    default         :        strcpy(erreur,"default code NULL");        break;    }    fprintf ( stdout,"\nErreur : %s \n", erreur); //on ÔøΩcrit l'erreur dans le terminal    if(code == QUITTER || !creation_popup_erreur(erreur)) //si la fonction creation_popup renvoie 0 alors l'utilisateur ÔøΩ dÔøΩcidÔøΩ de mettre fin au programme le code QUITTER permet de mettre dÔøΩfÔøΩnitivement fin au programme sans demandÔøΩ ÔøΩ l'utilisateur (exemple : bouton quitter dans l'accueil)    {        Mix_CloseAudio();        TTF_CloseFont(struct_jeu.police);        SDL_Quit();        IMG_Quit();        TTF_Quit();        abort();    }}/** * @file        init.h * @brief       Contient les d√©clarations des fonctions d'initialisation * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __INIT__#define __INIT__#include "struct.h"/*      FONCTIONS       */void initialisation_parametres();void chargement_police(int taille);void chargement_parametres();void sauvegarde_parametres();void quitter(int code);#endif // __INIT__/** * @file        sounds.h * @brief       Contient les d√©clarations des fonctions de son * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __SOUNDS__#define __SOUNDS__#include "struct.h"void creation_canaux_musique();void chargement_musique(int channel, int extra,int rep);void changement_volumes_musiques();void detruire_musique(int extra);#endif // __SOUNDS__/** * @file        timer.h * @brief       Contient les d√©clarations des fonctions de temps * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#ifndef __TIMER__#define __TIMER__#include "struct.h"/*  FONCTIONS   */void delay();void relever_fps();void action_timer();void initialisation_fps();#endif // __TIMER__/** * @file        timer.c * @brief       Contient l'impl√©mentation des fonctions de temps, SDL_Delay . . . * @author      A changer * @version     1.0 * @date        2021 * @copyright   Le Mans Universit√© */#include "include/timer.h"/** * \fn void delay() * \brief Cette fonction effectue une pause dans le programme pour faire correpondre les images affich√©es par le programme aux fps demand√©es par l'utilisateur (si le joueurs demande 60fps alors le programme ne devra faire une seule boucle par 16ms) */void delay(){    struct_jeu.tableau_fps[struct_jeu.frames_evolution%20]=1000/((struct_jeu.ticks_fin-struct_jeu.ticks_depart)?(struct_jeu.ticks_fin-struct_jeu.ticks_depart):1);    if(struct_jeu.frames_evolution%20)relever_fps();    struct_jeu.ticks_fin=SDL_GetTicks();    int difference=struct_jeu.ticks_fin-struct_jeu.ticks_depart;//cette diffÔøΩrence correspond au temps qu'a mis le programme ÔøΩ faire une boucle (ex:16ms -> 60FPS)    if(difference<(1000/jeu_parametres.plageFPS[jeu_parametres.fps]))//si la diffÔøΩrence est moins grande (le programme ÔøΩ mis moins de temps que l'ÔøΩquivalent des fps max alors le programme fait une pause de cette nouvelle diffÔøΩrence        SDL_Delay((1000/jeu_parametres.plageFPS[jeu_parametres.fps])-difference);    else        struct_jeu.ticks_depart=struct_jeu.ticks_fin;    if(struct_jeu.ticks_fin-TICKS_RATE_EVOLUTION>=struct_jeu.ticks_evo)    {        struct_jeu.ticks_evo=struct_jeu.ticks_fin;        struct_jeu.frames_evolution++;    }}/** * \fn void relever_fps() * \brief Cette fonction rel√®ve dans le tableau des fps, le nombre le plus bas, le plus haut et la moyenne. Si le porgramme va "trop vite" la fonction ne sortira pas de nombre plus haut que les fps  */void relever_fps(){    int compteur=0;    struct_jeu.fpsMax=0;    struct_jeu.fpsMin=jeu_parametres.plageFPS[jeu_parametres.fps];    for(int i=0; i<20; i++)    {        if(struct_jeu.tableau_fps[i]>struct_jeu.fpsMax)struct_jeu.fpsMax=struct_jeu.tableau_fps[i];        if(struct_jeu.tableau_fps[i]<struct_jeu.fpsMin)struct_jeu.fpsMin=struct_jeu.tableau_fps[i];        struct_jeu.fpsMoy+=struct_jeu.tableau_fps[i];        compteur++;    }    struct_jeu.fpsMoy/=(compteur?compteur:1);    if(struct_jeu.fpsMax>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMax=jeu_parametres.plageFPS[jeu_parametres.fps];    if(struct_jeu.fpsMin>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMin=jeu_parametres.plageFPS[jeu_parametres.fps];    if(struct_jeu.fpsMoy>jeu_parametres.plageFPS[jeu_parametres.fps])struct_jeu.fpsMoy=jeu_parametres.plageFPS[jeu_parametres.fps];}void action_timer(){    if(struct_jeu.ticks_fin-TICKS_RATE_ACTIONS>=struct_jeu.ticks_actions)    {        struct_jeu.ticks_actions=struct_jeu.ticks_fin;        avancer();        sauter();        attaquer();        coupspe();        repos();        pesanteur();    }}void initialisation_fps(){    jeu_parametres.plageFPS[0]=30;    jeu_parametres.plageFPS[1]=60;    jeu_parametres.plageFPS[2]=75;    jeu_parametres.plageFPS[3]=144;    jeu_parametres.plageFPS[4]=255;    jeu_parametres.plageFPS[5]=1000;    struct_jeu.ticks_depart=0;    struct_jeu.ticks_fin=1;    struct_jeu.frames_evolution=0;    memset(struct_jeu.tableau_fps,0,sizeof(int)*20);}
